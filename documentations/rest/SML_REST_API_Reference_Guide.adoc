= SymetryML REST API Reference Manual
:toc:
:toclevels: 2
:toc-placement: preamble
:doctype: book
:imagesdir: ./media/rest
:sectnums:

Copyright © 2020 by Symetry, Inc. +
14 Pine Street, Ste 6 +
Morristown, NJ 07960 +
All Rights Reserved +
March 31st, 2020

[[introduction]]
== Introduction

This reference manual describes the SymetryML REST Application Programing Interface (API) that is exposed from Symetry Inc. The API lets you create, update, and delete SymetryML projects that can be used for data-mining exploration and predictive modeling.

[[audience]]
=== Audience

This reference manual is intended for software developers who write client applications that interact with the SymetryML REST API. This reference manual provides a reference of all API operations, which return raw JSON. For optimal utilization of network bandwidth, the SymetryML REST API supports the consumption and creation of JSON data structures only, unless you use a data source from the <<data-source-api>>.

[[assumptions]]
=== Assumptions

This reference manual assumes that you have a general understanding of RESTful Web Services along with development tools, environments, and IDEs necessary to test and create an application in your programming language of choice. It also ensures that only users with the private key can make requests of those services.

Users of the SymetryML REST service must be authorized by Symetry Inc.

[[terminology]]
=== Terminology

The following table defines key terms related to the SymetryML REST API.

.

[width="100%", cols="<30%,<70%",options="header",]
|===================
|Term |Definition
|*SymetryML Projects* |Allow creation and deletion of SymetryML projects, learning and forgetting new data, and obtaining information about SymetryML projects.
|*Data source* |Data source are abstractions of CSV files residing either on Amazon S3, SFTP or HTTP|HTTPS.
|*Encoder* |In data mining, the process of transforming a categorical attribute into a continuous attribute is called _encoding._ Within SymetryML, an encoder object allows the user to transform high-cardinality attributes into meaningful data points that are more predictive than their original form for a particular target attribute
|*Data exploration* |Data mining and statistical exploration of SymetryML projects.
|*Model building* |Allows building models using various modeling algorithms, such as linear discriminant analysis (LDA), multiple linear regression (MLR), and quadratic discriminant analysis (QDA).
|*Model prediction* |Allows the use of previously built models to make predictions. Files on Amazon S3 can be used to make and store predictions.
|===================


[[symetryml-rest-api-security]]
== SymetryML REST API Security


[[symetryml-rest-request-authentication]]
=== SymetryML REST Request Authentication

The SymetryML REST API allows you to authenticate your requests. The API’s authentication is based on a "message-authentication code" signature created using specific parts of the REST API HTTP request.

Message authentication code (MAC) provides a way to verify the integrity of information sent in a REST request based on a secret key known only to the request sender and receiver. Because only two parties know the secret key, validating the MAC signature also authenticates the corresponding REST request. For this reason, each SymetryML API account has a secret key associated with its SymetryML key ID that is used to create a MAC signature for each REST request. The SymetryML server uses this secret key to verify signatures and authenticate all requests.

[[authentication-header]]
=== Authentication Header

The SymetryML REST API uses the HTTP Authorization header to pass authentication information to the server. The header contains the information in the following table <<authentication-header>>.

The most common MAC algorithms are Hash-based Message Authentication Code-Message Data 5 (HMAC-MD5) and HMAC-SHA2. The algorithm used in the SymetryML REST API is HMAC-SHA2, as specified in RFC 4868. For examples of how to sign your REST request, see <<appendixb>>

.Authentication Header Contents

[width="100%",cols="<40%,<60%",options="header",]
|==============================================================================================================================================
|Item |Description
|*Authorization* |Signature
|*Signature* |Base64( HMAC-SHA2(UTF-8-Encoding-Of( StringToSign ) ) );
|*StringToSign* |`` HTTP-Verb + "\n" +
    Content-MD5 + "\n" +
    SymetryML-Secret-Key + "\n" +
    Sym-Date Header + "\n" +
    SymetryML-key-Id + "\n" +
    RequestBody + "\n" +
    CanonicalizedResource + "\n" +
    URLQueryParameters + "\n"; ``
|*Sym-Date format* |See the section <<symetryml-date-header>>.
|*CanonicalizedResource* |<HTTP-Request-URI, from the protocol name up to the query string>
|*URLQueryParameters* |Any URL query parameters used in the REST request. If no query parameters are present, do not add null or a new line "\n".
|*RequestBody* |JSON request body. If there is no request body, omit this along with the newline ("\n") that follows it.
|==============================================================================================================================================

[[symetryml-date-header]]
==== SymetryML Date Header


Each SymetryML REST request must contain a SymetryML Date header. The content of this header is a date and time based on the Universal Coordinated Time/Greenwich Mean Time (UTC/GMT) time zone. This header is called "sym-date".

The SymetryML Date header must:

* Follow this syntax:

....
yyyy-MM-dd HH:mm:ss;nanoseconds
....

For example:

....
2014-07-31 08:01:07;1245
....

* Before 5 minutes of the server time.
* Not be more than 1 minute ahead of the server time.

[[authentication-errors]]
=== Authentication Errors

If an authentication error occurs, the server returns a 401 (UNAUTHORIZED) response. The response contains a stringToSign entity that describes the string that the server was trying to validate when the error occurred. You can use this string to troubleshoot the request and identify the validation issue.

NOTE:  The server omits the secret key from the response and outputs SECRETKEY in stringToSign.

The following shows an example of an unauthorized response. .

[source,json]
....
{
      "statusCode":"UNAUTHORIZED",
      "statusString":"Invalid Signature",
      "values":{
            "stringToSign":"DELETE\\n\\nSECRETKEY\\n2013-05-22 18:13:38\\nc1\\nhttp://192.168.0.19:8080/symetry/rest/c1/sYMETRYMLs/r1\\n"
      }
}
....


[[error-codes]]
=== Authenticaion Error Codes

To help you identify and resolve authentication issues quickly, the SymetryML REST API supports a variety of error codes. The following table describes the supported error codes.

.API Error Codes
[width="100%", cols="<,<,<",options="header",]
|===================================================================================================================================================================================
|Error Code |HTTP Code |Description
|*Md5 do not match* |400 |MD5 of the request body is invalid.
|*Invalid User* |401 |Server does not know this user.
|*Invalid Signature* |401 |Authentication header signature is invalid.
|*Authentication header not present* |400 |Authentication header is missing from the request.
|*SymetryML-date is not present* |400 |SymetryML date header is missing from the request.
|*Invalid Request Date* |400 |Date in the request is more than 5 minutes older than the server time.
|*Request time is after current time by more than 1 min* |400 |Timestamp on the request is more than 1 minute later than the server time. Check the time configuration on your client.
|*Invalid Date Format* |400 |Format of the SymetryML date header is invalid. See the section <<symetryml-date-header>> for information about the appropriate format to use.
|===================================================================================================================================================================================

[[apis-at-a-glance]]
=== APIs at-a-Glance

Please note that Every REST request that is made starts with the following canonical URL:

....
HTTPVERB /symetry/rest/{cid}
....

where:

* `{cid}` is the customer ID.
* HTTPVERB is a valid HTTP verb such as `GET`, `PUT`, `POST`, or `DELETE`.

[[symetryml-json-api-objects]]
== SymetryML JSON API Objects

[[http-request-body-for-json-objects]]
=== HTTP Request Body for JSON Objects

You must pass a JSON request body that is appropriate for the service being called. The following table describes the supported request bodies. For a detailed description about these objects, see <<AppendixA>>.

[width="100%",cols="<25%,<75%",options="header",]
|=================
|JSON Data Structure |Description
|*DataFrame* |Use when learning, forgetting, making predictions and modifying Encoder attributes values. DataFrame contains an attribute name list, an attribute types followed by an array of string. This organization is similar to a comma-separated value (CSV) file, where the first line usually is the header containing the name of each column (similar to the ‘attributes name list’ in our API), followed by _n_ lines that each contain _x_ values (where _x_ usually is the same length as the number of columns in the header).(see <<dataframe-json>>) DataFrame contains the following information: +
* *attributeNames* = name of the attributes or features in the dataframe. +
*  *attributeTypes* = type of the attributes. See About Attribute Types. +
* *data* = the actual data.
|*DSInfo* |Information about data source.(see <<dsinfo-json>>)
|*DSListingRequest* |Information about listing directory and files from data sources.(see <<dslistingrequest-json>>)
|*MLContext* |Used when building models and conducting data exploration requests. Use to specify attributes, target a request, and specify attribute(s) to use for Exploration requests.(see <<mlcontext-json>>)
|*ExploreContext* |List of MLContext that allows passing multiple MLContext when calling the REST exploration service. You can then request the same metric for various attributes or a combination of attributes.(see <<explorecontext-json>>) |
|=================

[[about-attribute-types]]
==== About Attribute Types

In SymetryML, It is possible to specify the type of the attributes in a <<dataframe-json, DataFrame>> Attribute type is specified using a single character for each of the attributes in the <<dataframe-json, DataFrame>> The following table describes the supported attribute types and their behavior.

[width="100%",cols="15%,15%,80%",options="header",]
|=============================
|Attribute Type |Description |Details
|*C* |Continuous |Use this to specify numbers.
|*B* |Binary |Only 1 and 0.
|*S* |String |Any String is allowed. Usually used in conjunction with an Encoder in a project (see Encoder Object REST API). If a project does not contain an encoder attribute with this type will be ignored..
|*L* |List |String values separated by '\|'. Usually used in conjunction with an Encoder in a project (see Encoder Object REST API). If a project does not contain an encoder attribute with this type will be ignored.
|*T* |Category |Attribute of these type will see all their different values seen as a different category. Under the hood, SymetryML creates ‘dynamic’ attributes for each the different values. +
                  This is a feature in SymetryML since version 3.5 that provides automatic handling of categorical values – usually in the form of string - by creating attribute on the fly in the project to represent them. The attribute being create will have a ‘Binary’ type and their actual name will be of the following form +
                  ***{BASE\_ATTRIBUTE}\${VALUE}*** +
                  Example: +
                  ***flowertype\$versicolor*** +
                  Values will be normalized by: +
                        -   Trimming the value. +
                        -   Changing it to lowercase.
|*X* |Ignore |Attribute with this type will be ignored.
|*-* |None |Internal Use Only
|=============================

[[http-response-for-json-objects]]
=== HTTP Response for JSON Objects

All SymetryML REST requests return a JSON response. Depending on the service requested, the response can contain additional response(s) entity(ies) (see <<table-additional-entities>>). For a detailed description about these objects, see <<AppendixA>>.

==== About JSON Strict Syntax

As of Version 5.0 SymetryML does not fully conform to the JSON syntax, more specificaly we can return float value like `Infinity` that are not part of the JSON specification. You might need to change the configuration of your JSON parser in order to allow it to be more lenient.

.Main SymetryML Response
[width="100%",cols="<25%,<75%",options="header",]
|==========
|Object |Description
|JSONResponse |All SymetryML Rest APIs return this object. This object contains the HTTP return code, as well as contextual information if an error occurs. A JSONResponse can also contain additional response entities, depending on the service requested. (see <<response-entities>>) |
|==========

[[table-additional-entities]]
.Additional Response Entities
[width="100%",cols="<25%,<75%",options="header",]
|==========
|JSON Entity |Description
|*DataFrame* (see <<dataframe-json>>) |DataFrame is returned as a response when using the SymetryML REST service on Data source files. For more information, see DataFrame JSON.
|*DSInfo* (<<dsinfo-json>>) |This JSON contains information about a data source. Depending on the type of the data source, the information it contains will be different. Currently, the following data sources are supported: +
                                    - Amazon S3 +
                                    - SFTP +
                                    - HTTP URL +
                                    - JDBC +
                                    - Spark RDD +
                                    - Amazon S3 with Spark processing +
                                    - Amazon RedShift +
                                    See DSInfo JSON for more information.
|*DSListingResponse* (see <<dslistingresponse-json>>) |This data structure is used to return data source listing information. It allows to list ‘folders’ and ‘files’ from a data source repository. For more information, see DSListingRequest JSON.
|*JobInfo* (see <<jobinfo-json>>) |Returns the following information about a specific job on the server: +
                                    - Job type +
                                    - Job Owner +
                                    - Whether the job has started yet +
                                    - Is Job finished +
                                    - Starting date of a job that has started. +
                                    - Maximum size of a file to process. +
                                    - Current size of a file that was processed. It is possible to compute the percentage of completion of a job by computing 'Current Size / Maximum Size'. +
                                    - In the case of a reducer model, the current size will reflect how much iteration were done so far. +
                                    For more information, see JobInfo.
|*KSVDMap* (see <<ksvdmap-json>>) |*Key String Value Double Map* +
                                    Data structure is an array of map<String, double>. For more information, see KSVDMap.
|*KSVSMap* (see <<ksvsmap-json>>) |*Key String Value Double Map* +
                                    Data structure is an array of map<String, double>. For more information, see KSVDMap.
|*ModelInfo* (see <<modelinfo-json>>) |Contains information about a model. All models have at least the following information: +
                                    - Attribute Name +
                                    - Attribute name ID used internally in the model +
                                    - Target(s) name +
                                    - Target(s) name ID from the SymetryML project +
                                    - modelBuilt = number of models built to eventually create that model. This number is greater than 1 if the model is the result of the Reducer process. +
                                    - buildTime = overall processing time required to build the model. This value includes reduce time that might have built more than one models. +
                                    Depending on the type of model, more information can be stored in the form of key/value string pairs.
|*ProjectInfo* (see <<projectinfo-json>>) |Holds the following information about a SymetryML project: +
                                    - ID of a SymetryML project +
                                    - List of attribute names +
                                    - List of attribute IDs +
                                    - List of attribute types: +
                                    - List of model IDs that belong to that SymetryML project +
                                    - Creation date +
                                    - Last modification date
|*ProjectInfoList* (see <<projectinfolist-json>>) |List of ProjectInfo.
|*StringList* (see <<stringlist-json>>) |Holds an array of string. This response is returned when asking for the list of SymetryML project IDs that was saved on Amazon S3 or when asking for the list of current job ID.
| *FederationInfo*  (see <<federationinfo-json>>) | Hold information about a federation. for more information consult the <<fedml-api>> section.
| *AwsInfo* (see <<awsinfo-json>>)| Data Structure that contains information about SNS topics, SQS queues and SNS subscripttions for a given AWS user. Please consult the <<fedml-api-get-aws-info>> for more information.
| *DensityList* (see <<densitylist-json>>)| The data structure returned by the <<density-estimate>> rest call.
|==========

[[rest-call-http-return-code]]
=== REST Call HTTP Return Code

Every service request to the SymetryML REST API returns an HTTP response code and HTTP header information that is appropriate for the service called. The following table lists the HTTP return codes. These return codes can be returned by any REST request.

.HTTP Return Codes
[[table-http-return-codes]]
[width="100%", cols="<25%,<75%",options="header",]
|=====================================================================================================================================================
|Return Code |Description
| 200 | OK, no error
| 201 | CREATED, a resource was created successfully, for instance a project or data source.
| 202 | ACCEPTED, typically returned when an asynchronous REST call return successfully.
|400, 401 and 409 | All authorization and authentication HTTP codes described in <<authentication-errors>>.
|500 INTERNAL SERVER ERROR |If an exception was raised while processing a request, this response contains information about the error that was raised.
|503 SERVICE NOT AVAILABLE |The SymetryML REST web application is not available. View your server logs to troubleshoot the issue.
|=====================================================================================================================================================

[[encoder-object-rest-api]]
== Encoder Object REST API

[[create-new-encoder-object]]
=== Create New Encoder Object

This API function call creates a new Encoder object.

[[url]]
==== URL
....
POST /symetry/rest/{cid}/encoders/create?encodername={name}&encoderTarget={target} [body = KSVSMap]
....

[[create-encoder-body]]
==== Create Encoder Body
It's possible to specify parameters when creating an encoder. These parameters are passed in a <<ksvsmap-json>> data structure. The following table list the possible key value pair that can be put in that map:

.create encoder ksvsmap info
[[create-encoder-ksvsmap-info]]
[width="100%", cols="<25%,<75%",options="header",]
|=====================================================================================================================================================
|Key |Value
|```minTrimSize``` | Set the number of positive examples for a key value to be kept in an encoder when performing trimming. That is if ```minTrimSize``` is 3 and a given key value was seen 25 time with 2 positive example, it will be trimmed. Note that this parameters only applies to Encoder with a binary target.
|=====================================================================================================================================================


[[query-parameters]]
==== Query Parameters

[width="100%", cols="<25%,<25%,<50%",options="header",]
|======================================================================================================================
|Parameter |Required/Optional? |Description
|encoderName |Required |Name of the new Encoder.
|encoderTarget |Required |Target attribute to use.
|targetType |optional |Target Type, valid values are 'C' for continuous based encoder and 'B' for binary based encoder.
|======================================================================================================================

[[http-responses]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|========================================================
|HTTP Status Code |HTTP Status Message |Description
|201 |CREATED |Success
|409 |CONFLICT |An encoder with same name already exists.
|========================================================

[[http-response-entity]]
==== HTTP Response Entity

None

[[sample-requestresponse]]
==== Sample Request/Response
....
Request:
GET url=http://charm:8080/symetry/rest/c1/encoders/create?encodername=enctest&targetName=clicked

Response:
{"statusCode":"CREATED","statusString":"Encoder[enctest] with Target[clicked] created for Customer[c1]","values":{}}
....

[[update-an-encoder]]
=== Update an Encoder

This API function call updates an existing Encoder.

[[url-1]]
==== URL
....
POST /symetry/rest/{cid}/encoders/{encodername}/learn [body = DataFrame]
....

[[http-responses-1]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success
|==================================================

[[http-response-entity-1]]
==== HTTP Response Entity

None

[[sample-requestresponse-1]]
==== Sample Request/Response

To be concise, we replaced some of the content of the body with (…) in the following example:
....
Request:
POST url=http://charm:8080/symetry/rest/c1/encoders/enctest/learn

Body:
{"attributeNames":["(...)"],"data":[["(...)]],"attributeTypes":["S","C","C","L","S","L","S","S","S","S","S","S","S","S","S","S","S","S","S","S","S","S","S","L","S","S","S","S","S","S","B","S","S","S","B","C","C","B","S","B","C","C","B","C","B"]}

Response:
{"statusCode":"OK","statusString":"OK","values":{}}
....

[[delete-an-encoder]]
=== Delete an Encoder

This API function call deletes an existing Encoder.

[[url-2]]
==== URL
....
DELETE /symetry/rest/{cid}/encoders/{encodername}
....

[[http-responses-2]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|============================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success
|409 |CONFLICT |Encoder is being used by a SymetryML project.
|============================================================

[[http-response-entity-2]]
==== HTTP Response Entity

None

[[encoder-statistics]]
=== Encoder Statistics

This API function returns information about the key present in an Encoder.

[[url-3]]
==== URL
....
GET /symetry/rest/{cid}/encoders/{encodername}/stats
....

[[http-responses-3]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success
|==================================================

[[http-response-entity-3]]
==== HTTP Response Entity

[width="100%",cols="<25%,<75%",options="header",]
|===============================================================================================================
|HTTP Response Entity |Description
|DataFrame |For each attribute (e.g., key) in this Encoder, the following columns are returned in the DataFrame:
(see <<dataframe-json>>) +
* Key +
* Type +
* Count = number of different values for this key. |
|===============================================================================================================

[[sample-requestresponse-2]]
==== Sample Request/Response
....
Request:
GET url=http://charm:8080/symetry/rest/c1/encoders/enctest/stats

Response:
{"statusCode":"OK","statusString":"OK","values":{"dataframe":{"attributeNames":["key","type","count","mean","stddev","variance"],"data":[["adexchange","S","1.0","34452.0","0.0","0.0"],["badv_count","B","0.0","0.0","0.0","0.0"],["bcat_count","C","0.0","0.0","0.0","0.0"],["bid_price","C","0.0","0.0","0.0","0.0"],["campaign","S","16.0","2153.25","5851.762725880126","3.4243127E7"],["category","S","18.0","1914.0","3205.867011296265","1.0277583294117646E7"],["category_count","B","0.0","0.0","0.0","0.0"], (…) ]}}}
....
[[encoder-specific-key-values]]
=== Encoder Specific Key Values

This API function lets you obtain detailed information about all the values for a given key.

[[url-4]]
==== URL
....
GET /symetry/rest/{cid}/encoders/{encodername}/keyvals/{key}
....
[[http-responses-4]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success
|==================================================

[[http-response-entity-4]]
==== HTTP Response Entity

[width="100%",cols="<25%,<75%",options="header",]
|======================================================================================
|HTTP Response Entity |Description
|DataFrame |For each values of the given {key}, the following information is returned:
(see <<dataframe-json>> )  +
* Value +
* Type +
* Count +
*  Sum |
|======================================================================================

[[sample-requestresponse-3]]
==== Sample Request/Response
....
Request:
GET url="http://charm:8080/symetry/rest/c1/encoders/enctest/keyvals/device_country"

Response:
{"statusCode":"OK","statusString":"OK","values":{"dataframe":{"attributeNames":["Value","Type","Count","Sum"],"data":[["","S","21","0.0"],["703","S","1","0.0"],["a1","S","6","0.0"],["a2","S","488","12.0"],["af","S","2","0.0"], (…)
]}}}
....

[[encoder-modify-specific-key-values]]
=== Encoder Modify Specific Key Values

This API function lets you modify specific key values in the Encoder. When invoking this REST endpoint, the server expects to receive the following columns in the DataFrame (see <<dataframe-json>>) in the order shown below.

1.  Key value to change count and/or sum
2.  Type
3.  New Count
4.  New Sum

[[url-5]]
==== URL
....
POST /symetry/rest/{cid}/encoders/{encodername}/keyvals/{key}/setValue [body=DataFrame]
....
[[http-responses-5]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success
|==================================================

[[http-response-entity-5]]
==== HTTP Response Entity

None

[[sample-requestresponse-4]]
==== Sample Request/Response
....
Request:
POST url="http://charm:8080/symetry/rest/c1/encoders/enctest/keyvals/device_country/setValues

Body:
{"attributeNames":["Value","Type","Count","Sum"],"data":[["ap","S","400","6"]]}

Response:
{"statusCode":"OK","statusString":"OK","values":{}}
....

[[encoder-create-specific-key-values]]
=== Encoder Create Specific Key Values

This API function lets you create new key values in the Encoder. When invoking this REST endpoint, the server expects to receive the following columns in the DataFrame (see <<dataframe-json>>) in the order shown below.

1.  Key to add a value. If the key does not exist, it will be created.
2.  Key value to addcount and sum.
3.  Key type.
4.  Count for the new key.
5.  sum for the new key.

[[url-6]]
==== URL
....
POST /symetry/rest/{cid}/encoders/{encodername}/createKeyValues [body=DataFrame]
....
[[http-responses-6]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success
|==================================================

[[http-response-entity-6]]
==== HTTP Response Entity

None

[[sample-requestresponse-5]]
==== Sample Request/Response
....
Request:
POST url="http://charm:8080/symetry/rest/c1/encoders/enctest/createKeyValues"

Body:
{"attributeNames":["Key","Value","Type","Count","Sum"],"data":[["device_country","ap","S","400","6"]]}

Response:
{"statusCode":"OK","statusString":"OK","values":{}}
....

[[list-customer-encoders]]
=== List Customer Encoders

This API function returns a list of encoder names that were created by a given user.

[[url-7]]
==== URL
....
GET /symetry/rest/{cid}/encoders
....

[[http-responses-7]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success
|==================================================

[[http-response-entity-7]]
==== HTTP Response Entity

StringList (see <<stringlist-json>>)

[[sample-requestresponse-6]]
==== Sample Request/Response

Request:
....
GET url="http://charm:8080/symetry/rest/c1/encoders"

Response:
{"statusCode":"OK","statusString":"OK","values":{"stringList":{"values":["enctest","smaato12"]}}}
....

[[symetryml-projects-rest-api]]
== SymetryML Projects REST API

=== About SymetryML Projects Life-Cycle

SymetryML project are different than _classical_ machine learning or other data science projects in the way data is ingested and in how machine learning models are created. Normally one would create a machine learning model by specifying some file(s) or data structure containing the data description - number of rows, input attributes, target(s) for models. This step can be highly memory intensive if the data to be processed is large.

SymetryML is different. There is no limitation on the number of rows that can be processed and the number of rows do not impact the memory requirement to build a model. Updating a project with some data and building a machine learning model based on a project are 2 separates operations:

* When updating a project - that is learning or forgetting some data - internally some representation of the data is being updated. This update is usually quite fast. This internal representation can be queried in real time using the <<exploration-api>>.
* When building a model, The internal representation is used to extract values needed by each different machine learning models supported by SymetryML. This makes model building very quick, usually under a few milli-seconds. If another models is needed perhaps with differents inputs and/or target(s), one just need to issue a request to build another model and no _re-scanning_ of the data is needed. Models are built based on the current state of a project. If a project was updated with some data, a rebuild of the model might be needed so that the models use the latest data available in the project.

[[about-symetryml-project-type]]
=== About SymetryML Project Type

New with SymetryML version 5. are “Federated” project types. The following table describes the difference between these project types and when to use them. For more details on Federated Project please consult this section: <<about-federated-projects>>.

.Project Types

[width="100%",cols="<25%,<75%",options="header",]
|===================
|Type |Description
|cpu or dynamic |- Project update (learn/forget) done on CPU. +
- Project stored on CPU memory. +
- Use this type of project if you have categorical attributes or fewer than 50-100 attributes.
|gpu |- Project update (learn/forget) done on GPU. +
- Project stored on GPU memory. +
- Use this type of project if you have dense data with more than 100 attributes. Please note that you cannot directly use category with a GPU project type. Such data needs to be one hot encoded before pushing it into a SymetryML GPU project.
|multi gpu |- Project update (learn/forget) done on multiple GPUs. +
- Project stored on multiple GPUs memory. +
- Use this type of project if you have dense data with more than 1000 attributes and you have multiple GPUs available. Please note that you cannot directly use category with a GPU project type. Such data needs to be one hot encoded before pushing it into a SymetryML GPU project.
|Sequence |SymetryML need to perform some additional logic for these type of models to be built. Use the 'sequence' project type so that you can build such models on your data. See the section <<about-sequence-projects>> for more details.
|Partitionned | Use this type of project if you need to use LDA model with multi-class classifier or if you need to build a QDA model. When creating such projects one needs to specify the attribute that will be used to partition the project. This attribute needs to be of type ```String``` and usually should be the target for building your LDA or QDA models.
|Hash-trick | This type of project encoder is ideally suited for datasets with large number of categorical values. The hashing operation limits the cardinality of categorical attributes to a more manageable number.
|Federated Project | Federated Project allows multiple SymetryML projects to form a _federation_ that leverage each individual projects so that they all work together as if they were one single project. That is from the perspective of each individual project they can all build the same models or compute the same exploration metrics and all of this is accomplished without sharing any data. For more information please consult the <<about-federated-projects, Federated Project Section.>>
|===================

[[about-partitioned-projects]]
=== About Partitioned Projects

New with SymetryML 4.2 is the ability to create 'Partitioned Projects'. Partitioned project allows you to build Multi-Class LDA models as well as QDA models. When creating such projects one must specifies which attributes will be the target for these models, this parameter is called the _partition column_. This parameter is mandatory. Please refer to <<sample-requestresponse-partitioned>> for an sample REST request / response.


[[about-hashtrick-projects]]
=== About Hashtrick Projects

Also new with SymetryML 4.2 is the ability to create 'Hashtrick Projects'. Use these type of project when your projet have many categorical attributes. When using such project the number of attributes / features will be reduced using the hashtrick. Note that you might need to experiments in order to find the optimal _bucket size_. Please refer to <<sample-requestresponse-hashtrick>> for an sample REST request / response.


[[about-sequence-projects]]
=== About Sequence Projects

With the release of SymetryML version4.1 came the ability to use Markov Chains and Hidden Markov Model. To build such models, you create a sequence SymetryML Project and specify its order. Order defines your _ngrams_ that will be learned and the level of you _ngrams_ will be a given values in a dataframe. For Markov chains, specify a categorical attribute for the input of your model. For the Hidden Markov Model, the observed state can be categorical or continuous, but the hidden must be categorical.

For the sequence project, SymetryML interprets the dataframe data structure differently:

* If a Dataframe to be processed has only 1 attributes, it will be assumed that each line represent a token or level of a sequence.
* If a DataFrame to be processed has more than one columns, it will be assumed that each line represent a sequence to learned.

For more information on __ngrams__, order, and level, see https://en.wikipedia.org/wiki/N-gram.


[[about-federated-projects]]
=== About Federated Projects

New with version 5.0 of SymetryML is the capabilities to allows multiple SymetryProject - possibly on different sites / geographical locations / different business units - to synchronize with each other in order to leverage each others data without sharing the actual data. This functionality is called `Federated Learning`. A federated project act exactly the same as any other project in terms of how you build model or explore the data. The only difference is how you create them. For more details about the lifecycle of federated project please consult the <<fedml-api>> section.


[[create-new-symetryml-project]]
=== Create New SymetryML project

This API function call renames a SymetryML project.

[[url-8]]
==== URL
....
POST /symetry/rest/{cid}/projects?pid={new-project-id} [body=KSVSMap]
....

[[create-new-symetryml-body]]
==== Create New SymetryML project Body

The body of the request consist of a key/value map. It is optional and depends on the type of project. Please refer to the following table that describes mandatory parameters for the different type of projects. Also refer to <<ksvsmap-json>> for detail on the request body json datastructure.

.Create Project Map key value
[width="100%",cols="<12%,<13%,<75%",options="header",]
|==========================================================================================================================================================================================================================================
|Type |Mandatory Parameters | Description
|*cpu* | none |
|*gpu* | none |
|*Sequence* | sml_project_order | specify the sequence order (ngram)
|*Partitionned* | partitionSplit | specify which attribute / column to use to split the partition
|==========================================================================================================================================================================================================================================

[[query-parameters-1]]
==== Create Project Query Parameters

[width="100%",cols="<25%,<25%,<50%",options="header",]
|=================================
|Parameter |Required/Optional? |Description
|pid |Required |Name of the new SymetryML project.
|Type |Optional |Possible types include cpu, gpu or sequence. Default is dynamic project; that is SymetryML will use CPU resources for any computation related to this project.
|persist |Optional |Whether to persist or not a project. Valid values are +
* true +
* false
| enableHistogram | Optional | Enable histogram for continuous and binary attributes in this project.
|=================================

[[http-responses-8]]
==== HTTP Responses

[width="100%",cols="<25%,<25%,<50%",options="header",]
|================================================================
|HTTP Status Code |HTTP Status Message |Description
|201 |CREATED |Success. +
`{"statusCode":"CREATED","statusString":" +
SYMETRYML Created with id:r1","values":{}}`
|409 |CONFLICT |SymetryML project already exists. +
`{"statusCode":"CONFLICT","statusString":" +
Customer [c1] already have SYMETRYML with id[r1], ","values":{}}`
|================================================================

[[http-response-entity-8]]
==== HTTP Response Entity

None

[[sample-requestresponse-standard]]
==== Sample Request/Response CPU/GPU Projects
....
POST url="http://charm:8080/symetry/rest/c1/projects?pid=testIris

{"statusCode":"CREATED","statusString":"Project Created with id:testIris","values":{}}
....

[[sample-requestresponse-partitioned]]
==== Sample Request/Response Partitioned Projects
....
Request:
POST url=http://charm:8080/symetry/rest/c1/projects?pid=irisMeta&type=partition&persist=true

Request Body:
{"partitionSplit":"class"}

Response:
{"statusCode":"CREATED","statusString":"Project Created with id:irisMeta","values":{}}
....

[[sample-requestresponse-sequence]]
==== Sample Request/Response Sequence Projects
....
Request:
POST url=http://charm:8080/symetry/rest/c1/projects?pid=activityMC&type=sequence

Request Body:
{"sml_project_order":"1"}

Response:
{"statusCode":"CREATED","statusString":"Project Created with id:activityMC","values":{}}
....

[[sample-requestresponse-hashtrick]]
==== Sample Request/Response Hash-trick Projects
....
Request:
POST url=http://charm:8080/symetry/rest/c1/projects?pid=CRITEO&type=cpu

Request Body:
{"sml_project_hashtrick_binsize":"1024"}

Response:
{"statusCode":"CREATED","statusString":"Project Created with id:CRITEO","values":{}}
....

[[rename-a-symetryml-project]]
=== Rename a SymetryML project

This API function call renames a SymetryML project.

[[url-9]]
==== URL
....
GET /symetry/rest/{cid}/projects/{pid}/rename?newName={newname}
....
[[query-parameters-2]]
==== Query Parameters

[width="100%", cols="<25%,<25%,<50%",options="header",]
|=====================================================
|Parameter |Required/Optional? |Description
|rename |Required |New name for the SymetryML project.
|=====================================================

[[http-responses-9]]
==== HTTP Responses

[width="100%",cols="<25%,<25%,<50%",options="header",]
|===============================================================================================================
|HTTP Status Code |HTTP Status Message |Description
|201 |CREATED |Success. +
`{"statusCode":"CREATED","statusString": +
"SYMETRYML Created with id:r1","values":{}}`
|409 |CONFLICT |A SymetryML project by the specified new name already exists. +
`{"statusCode":"CONFLICT","statusString":"Customer [c1] already have SYMETRYML with id[r1], ","values":{}}`
|===============================================================================================================

[[http-response-entity-9]]
==== HTTP Response Entity

None

[[assign-an-encoder-to-a-symetryml-project]]
=== Assign an Encoder to a SymetryML Project

This API function call renames a SymetryML project.

[[url-10]]
==== URL
....
GET /symetry/rest/{cid}/projects/{pid}/encoderAssign?encoderName={encname}
....

[[query-parameters-3]]
==== Query Parameters

[width="100%", cols="<25%,<25%,<50%",options="header",]
|======================================================================
|Parameter |Required/Optional? |Description
|encodername |Required |Encoder name to use for this SymetryML project.
|======================================================================

[[http-responses-10]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|==================================================

[[http-response-entity-10]]
==== HTTP Response Entity

None

[[delete-a-symetryml-project]]
=== Delete a SymetryML project

This API function call deletes a SymetryML project from your repository.

[[url-11]]
==== URL
....
DELETE /symetry/{cid}/projects/{pid}
....

[[http-responses-11]]
==== HTTP Responses

[width="100%",cols="<25%,<25%,<50%",options="header",]
|==========================================================================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success. +
`{"statusCode":"OK","statusString":"deleted Project with id[r1] from Customer[c1] store","values":{}}`
|400 |BAD REQUEST |User does not have the SymetryML project. +
`{"statusCode":"BAD_REQUEST","statusString":" +
Customer[c1] does not have Project with id[r1], ","values":{}}`
|==========================================================================================================

[[http-response-entity-11]]
==== HTTP Response Entity

None

[[list-symetryml-projects]]
=== List SymetryML projects

This API function call retrieves a list of SymetryML IDs that were created previously by a given user. The response contains a string list with the entire projects name that belongs to the user who made the request. The format of the response is described in section <<stringlist-json>>

[[url-12]]
==== URL
....
GET /symetry/rest/{cid}/projects/list
....

[[http-responses-12]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|==================================================

[[http-response-entity-12]]
==== HTTP Response Entity

[width="100%",cols="<25%,<75%",options="header",]
|================================================================================================================
|HTTP Response Entity |Example
|StringList  +
(see <<stringlist-json>>)
|`{"statusCode":"OK","statusString":"OK","values":{"stringList":{"values":["r1","r11","r2","r3"]}}}`
|================================================================================================================

[[sample-json-response]]
==== Sample JSON Response
....
Request:
GET url="http://charm:8080/symetry/rest/c1/projects/list

Response:
{"statusCode":"OK","statusString":"OK","values":{"stringList":{"values":["irisTest","anotherProject"]}}}
....

[[symetryml-project-unload]]
=== SymetryML Project Unload

In order to save memory on the server, it's possible to unload a project from memory. Note that if you do that with a project that is not persisted then the project cannot be restored.

[[symetryml-project-unload-url]]
==== URL
....
GET /symetry/rest/{cid}/projects/{pid}/unload
....

[[symetryml-project-unload-response]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|==================================================

[[symetryml-project-merge]]
=== SymetryML Project Merge

It's possible to merge 2 SymetryML projects together using the following rest endpoint.

[[symetryml-project-merge-url]]
==== URL
....
GET /symetry/rest/{cid}/projects/{pid}/merge?otherProjectName={otherProject}
....

[[symetryml-project-merge-query]]
==== Query Parameters

[width="100%",cols="<25%,<25%,<50%",options="header",]
|======================================================================================================================================================================================
|Parameter |Required/Optional? |Description
|*otherProject* |Required |Name of the other SymetryML project to use for the merging. At the end of this operation ```otherProject``` will be merge into ```pid```. That is ```otherProject``` will stay the same while ```pid``` will be updated with the content of ```otherProject```.
|======================================================================================================================================================================================

[[symetryml-project-merge-response]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|==================================================



[[symetryml-project-information-about-one-project]]
=== SymetryML Project Information About One Project

This REST API function call retrieves information about a single SymetryML project. The following information about a particular SymetryML project is returned as part of the ProjectInfo JSON response. (see the section <<projectinfo-json>>.

[width="100%",cols="<25%,<75%",options="header",]
|==================================================================================
|Field |Description
|*modelsList* |List of models
|*modelTypeList* |List of model types
|*dsList* |List of data source names
|*encoderName* |Encoder name if the SymetryML project use an encoder
|*attributeNames* |List of attributes names
|*attributeIndexes* |List of attributes index
|*attributeTypes* |List of attributes type. For example: +
                  - ([C] = continuous +
                  - [B] = binary +
                  - [S] = string +
                  - [L] = list +
                  - [X] = ignore
|*pid* |Name of this object
|*hash* |Internal use only
|*isDirty* |Internal use only. This field is deprecated.
|*creationDate* |Date this project was created.
|*lastModificationDate* |Last time data was added / learned on this project.
|*modelAssessment* |Internal use. List of assessments from SymetryML Web application
|*modelPredictions* |Internal use. List of predictions from SymetryML Web application
|*categorySeparator* |Internal use.
|*loaded*| Specifies if a project is loaded in memory or not
|*persisted*| Specifies if a project is persisted or not
|==================================================================================

[[url-13]]
==== URL
....
GET /symetry/rest/{cid}/projects/{pid}/info
....

[[http-responses-13]]
==== HTTP Responses

[width="100%",cols="<25%,<25%,<50%",options="header",]
|================================================================================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|400 |BAD REQUEST |SymetryML project does not exist. +
`{"statusCode":"BAD_REQUEST","statusString":"Cannot Find SYMETRYML id[r5] for Customer id [c1]","values":{}`
|================================================================================================================

[[http-response-entity-13]]
==== HTTP Response Entity

[width="100%",cols="<25%,<75%",options="header",]
|===================================
|HTTP Response Entity |Description
|ProjectInfo +
(see <<projectinfo-json>>)
|See the example below.
|===================================

[[sample-requestresponse-8]]
==== Sample Request/Response
....
Request:
GET url="http://charm:8080/symetry/rest/c1/projects/irisTest/info"

Response:
{"statusCode":"OK","statusString":"OK","values":{"smlInfo":{"modelsList":["ldaReduced","svmModel"],"modelTypeList":["lda","lsvm"],"attributeNames":["sepal_length","sepal_width","petal_length","petal_width","sepal_lengt_b1","sepal_lengt_b2","sepal_width_b1","sepal_width_b2","petal_length_b1","petal_length_b2","petal_width_b1","petal_width_b2","Iris_setosa","Iris_versicolor","Iris_virginica"],"attributeIndexes":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14],"attributeTypes":["C","C","C","C","B","B","B","B","B","B","B","B","B","B","B"],"pid":"irisTest","attributeStates":["u","u","u","u","u","u","u","u","u","u","u","u","u","u","u"],"hash":-1,"isDirty":true}}}
....

[[symetryml-project-information-about-all-projects]]
=== SymetryML Project Information About All Projects

This REST API function call returns information about all SymetryML projects that were created previously by a given user. To conserve memory usage, minimal information about each SymetryML project loads into server memory. If more information is required, it is loaded "lazily and transparently" by the server. For more information about the response format, see the <<projectinfolist-json>> section.

This API function is asynchronous. If it succeeds, it returns a 202 response, along with a Location header that specifies the job URL. For more information about asynchronous REST calls, see the section "Asynchronous Learning."

[[url-14]]
==== URL
....
GET /symetry/rest/{cid}/projects/info
....

[[http-responses-14]]
==== HTTP Responses

[width="100%",cols="<25%,<25%,<50%",options="header",]
|===================================================================================================================================================
|HTTP Status Code |HTTP Status Message |Description
|202 |ACCEPTED |Success. Includes an HTTP Location header specifying the location of the job ID that was created to handle the request. For example: +
`{"statusCode":"ACCEPTED","statusString":"Job Created","values":{}}`
|===================================================================================================================================================

After a Restore job completes, it returns the following information:

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================================================================================================================================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Response entity is an ProjectInfoList JSON data structure (see <<projectinfolist-json>>). For each SymetryML project ID restored, the entity contains its ID as well as the ID of models that belong to it.
|202 |ACCEPTED |Job is not finished. Includes a JobInfo entity. For more information, see the section <<symetryml-job-information>>.
|==================================================================================================================================================================================================

[[http-response-entity-14]]
==== HTTP Response Entity

None

[[sample-requestresponse-9]]
==== Sample Request/Response
....
Request
GET url="http://charm:8080/symetry/rest/c1/projects/info"

Response Header:
Location: http://charm:8080/symetry/rest/c1/jobs/4

Response:
{"statusCode":"ACCEPTED","statusString":"Job Created","values":{}}

Job Request:
GET url="http://charm:8080/symetry/rest/c1/jobs/4

Job Response:
{"statusCode":"OK","statusString":"Job is finished","values":{"smlInfoList":{"values":[{"modelsList":[],"modelTypeList":[],"attributeNames":[],"attributeIndexes":[],"attributeTypes":[],"pid":"anotherProject","attributeStates":[],"hash":-1,"isDirty":true},{"modelsList":["ldaReduced","svmModel"],"modelTypeList":["lda","lsvm"],"attributeNames":["sepal_length","sepal_width","petal_length","petal_width","sepal_lengt_b1","sepal_lengt_b2","sepal_width_b1","sepal_width_b2","petal_length_b1","petal_length_b2","petal_width_b1","petal_width_b2","Iris_setosa","Iris_versicolor","Iris_virginica"],"attributeIndexes":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14],"attributeTypes":["C","C","C","C","B","B","B","B","B","B","B","B","B","B","B"],"pid":"irisTest","attributeStates":["u","u","u","u","u","u","u","u","u","u","u","u","u","u","u"],"hash":-1,"isDirty":true}]},"ac":"z3SMHWgE8cqIHJUtBDV8Fg\u003d\u003d","Options":{"gpuEnabled":0}}
....

[[learning-and-updating-symetryml-projects]]
=== Real Time Streaming of Data into SymetryML Projects

SymetryML projects support streaming data. The streaming capabilities is encompassed in 2 major functionalities:

1. Using the <<learn-new-data-incremental-update>> or <<forgetting-data-decremental-update>> by providing a <<dataframe-json>> as the request body.
2. Using the <<stream-api>> to create stream data source that automatically push streaming data into your SymetryML project. Use this API to managage connections to streaming server solution such as Apache Kafka.

The following sub-sections will describe the _learn_ and _forget_ streaming API.

[[asynchronous-learning]]
==== Asynchronous Learning

Both the learn and forget methods can be invoked synchronously or asynchronously. The default method is synchronous. To run the task asynchronously, add async=true as a query parameter to your REST invocation. When invoked, the response is `202 ACCEPTED` and you can use the Job Status API to determine when a learning job is finished. For more information, see the section <<data-source-encryption>>

Usually, there is no need to run learn and forget tasks asynchronously unless your data has a large number of attributes that, depending on your hardware, can take more or less time to be executed. As a rule of thumb, data with fewer than 100 attributes can be learned and forgotten safely using synchronous execution. However, your experiences might be different. Therefore, if your data has a large number of attributes, we recommend that you perform testing to determine whether the asynchronous or synchronous method will work better for you.


NOTE: Addition of new attributes is handled by the incremental update automatically, as described in the next section.


[[learn-new-data-incremental-update]]
==== Learn New Data (Incremental Update)

This API function call learns new data. The body of the request should contain a DataFrame JSON data structure. For information about this JSON data structure, see the section <<dataframe-json>>. For information about the async parameter, see the section <<asynchronous-learning>>

[[url-15]]
==== URL
....
POST /symetry/rest/{cid}/projects/{pid}/learn [?async=true]* [body = DataFrame]
....
[[query-parameters-4]]
==== Query Parameters

[width="100%",cols="<25%,<25%,<50%",options="header",]
|=============================================================================================================================================
|Parameter |Required/Optional? |Description
|async |Optional |Performs the operation asynchronously. We recommend using true for this parameter if your data is wider than 100 attributes. +
Default: false
|=============================================================================================================================================

[[http-responses-15]]
==== HTTP Responses

[width="100%",cols="<25%,<25%,<50%",options="header",]
|=================================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
`{"statusCode":"OK","statusString":"OK","values":{}}`
|202 |Accepted |If async == true, the server accepted the request.
|400 |BAD REQUEST |SymetryML project cannot be found.
`{"statusCode":"BAD_REQUEST","statusString":" +
Cannot Find SYMETRYML id[r2] for Customer id [c1]","values":{}}`
|=================================================================

[[http-response-entity-15]]
==== HTTP Response Entity

None

[[sample-requestresponse-10]]
==== Sample Request/Response
....
Request:
POST url="http://charm:8080/symetry/rest/c1/projects/irisTest/learn?async=false"

Body:
{"attributeNames":["sepal_length","sepal_width","petal_length","petal_width","sepal_lengt_b1","sepal_lengt_b2","sepal_width_b1","sepal_width_b2","petal_length_b1","petal_length_b2","petal_width_b1","petal_width_b2","Iris_setosa","Iris_versicolor","Iris_virginica"],"data":[["4.3","3","1.1","0.1","1","0","0","1","1","0","1","0","1","0","0"],["4.8","3","1.4","0.1","1","0","0","1","1","0","1","0","1","0","0"],["4.9","3.1","1.5","0.1","1","0","0","1","1","0","1","0","1","0","0"]],"attributeTypes":["C","C","C","C","B","B","B","B","B","B","B","B","B","B","B"]}

Response:
{"statusCode":"OK","statusString":"OK","values":{}}
....

[[forgetting-data-decremental-update]]
==== Forgetting Data (Decremental Update)

This API function call allows users to forget data. The body of the request should contain a DataFrame JSON data structure. For information about this JSON data structure, see the section <<dataframe-json>>. For information about the async parameter, see the section <<asynchronous-learning>>.

[[url-16]]
==== URL
....
POST /symetry/rest/{cid}/projects/{pid}/forget [?async=true]* [body=DataFrame]
....

[[query-parameters-5]]
==== Query Parameters

[width="100%",cols="<25%,<25%,<50%",options="header",]
|=============================================================================================================================================
|Parameter |Required/Optional? |Description
|async |Optional |Performs the operation asynchronously. We recommend using true for this parameter if your data is wider than 100 attributes. +
Default: false
|=============================================================================================================================================

[[http-responses-16]]
==== HTTP Responses

[width="100%",cols="<25%,<25%,<50%",options="header",]
|===============================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
`{"statusCode":"OK","statusString":"OK"," +
values":{}}`
|400 |BAD REQUEST |If SymetryML project cannot be found:
`{"statusCode":"BAD_REQUEST","statusString":" +
Cannot Find SYMETRYML id[r2] for Customer id [c1]","values":{}}`
|===============================================================

[[http-response-entity-16]]
==== HTTP Response Entity

None

[[sample-requestresponse-11]]
==== Sample Request/Response

See the sample in the previous section <<sample-requestresponse-10>>


[[fedml]]
== About Federated Learning

This section will give background needed in order to understand the business object behind the Federated Learning functionality. The next section <<fedml-api>> will go into the details about the REST API itself.

[[fedml-terminology]]
=== Federated Project Terminology

SymetryML projects can easily be merged together. That is, imagine you have 2 projects: (a) a project _p1_ that processed dataset _d1_ and (b) a project _p2_ that processed dataset _d2_. You can merge _p2_ into _p1_ and the resulting _p1_ project will be the same as if _p1_ would have processed the datasets _d1_ and _d2_. This capability is leveraged in a SymetryML Federated project. A federation consists of _n_ SymetryProjects that each process their own private data and share their results at a given interval. This can be seen in the following picture:


[[id-fedml-3nodes]]
image::fedml-1.png[title='Example of 3 nodes federation', scaledwidth=95.0%]

In order to fully understand the federated learning REST API one needs to understand a few concepts / terminology.

[[fedml-terminology-table]]
==== Federation Terminology
[width="100%",cols="<40%,<60%",options="header",]
|==========
| Term | Definition 
| `peers` or `node` | A node is a member of a federation. It's basically a Symetry project.
| `federated project` | A Federated Symetry Project contains 2 symetry projects. One `local project` and one `federated project`. The federated project is rebuilt from time to time according the the `Federation Schedule` defined by the `federation admin`.
| `local project` | A Federated Symetry Project contains 2 projects. One local project and one `federated project`. The `local project` is responsible to process data that is *local* to this project.
| `Federation` | A federation is a set of `nodes` that communicate and share Symetry project information
| `Federation Info` | Information that describes a federation. 
| `Federation Admin` | The user who creates a federation automatically becomes the federation admin.
| `Federation secret key` | An AES secret key that is used to encrypt communication between peers/nodes of a federation.
| `Federation Schedule` | `Peers` in a `federation` will send updates to other `peers` according to a schedule. This schedule is defined by the `federation admin` when a `federation` is created. Example of schedule: +
- *m30* : synchronize every 30 mins + 
- *h3* : synchronize every 3 hours + 
- *d7* : synchronize every 7 days +
| `scheduled synchronization message` | A  periodic message sent by a `peer` to other `peers` in a `federation`. The period is defined by the `federation schedule`.
|==========

In the current implementation, under the hood the federation service uses many AWS service:

* Each federation node has an AWS SQS queue to receive messages
* A Federation has an AWS SNS topic that allows fanout messages to be sent to multiple SQS queues.
* Nodes in the federation use message to the SNS topic to communicate with other nodes
* SNS messages are lightweight and contain pointers to Amazon S3 files that are used to temporarily store message content.
* AWS STS credentials are used to allow other users to access an user's file on S3.
* The following figure illustrates this:

[[id-fedml-aws-integration]]
image::fedml-2.png[title='Fedederated SML AWS Integration', scaledwidth=95.0%]


[[fedml-use-cases]]
=== Federated Project Uses Cases


==== Create a Federation

The user who creates a federation will become the administrator of it.


==== Join a federation

In order to join a federation one must: + 

1. *Make sure that your clock is correctly synched* using a _ntp_ service or something similar. If a computer's clock, in a federation, is not correctly synched it will have problems receiving messages from other nodes as the service will ignore many messages because of the discrepancy between the time a message was sent and the internal clock of the computer receiving the message. Those errors could be seen using the <<fedml-api-get-error-log>> rest endpoint.
 
2. Receive `one-time encrypted federation info` along with the password to decrypt the message. This can be done over email, Skype or any other means that allows transfering some base64 encrypted text. The federation administrator can get this encrypted federation info using the <<fedml-api-get-encrypted>> rest endpoint

3. Invoke the rest point to join the federation <<fedml-api-join>> with the encrypted message and the password received from the federation admin. This message is also to be encrypted using the user `secret key`.

4. Upon successful result from step 3, one can now start syncing with other nodes in the federation. This is done by invoking the <<fedml-api-start-pulse>> rest endpoint.



[[fedml-api-at-glance]]
=== Federated Project REST API at a Glance

Beside creating and joining a federation via rest endpoints, others operations are available. The following table lists all available rest endpoints federated learning. The following functionality of normal SymetryML projects are available in Federated Project

* <<exploration-api>>
* <<modeling-api>>
* <<prediction-api>>
* <<data-source-api>>
* <<websocket-api>>

==== Limitation of Federated Project

* Features hashing is not available
* If your project has more than 3000 attributes you should be careful on how frequently you sync your projects. Please consult the <<fedml-terminology-table>> section for more information.

.Federated Project REST API at a Glance
[width="100%",cols="<25%,<75%",options="header",]
|==========
| Action | Definition 
| <<fedml-api-create,Create a new Federation>> | This rest endpoint is used to create a new federation. The user
performing this operation will become the owner of the federation.
| <<fedml-api-get-info,Get Federation Info>> | This is a map of properties for a federation.
| <<fedml-api-get-encrypted,Get Encrypted Federation Info>> | Return the Federation information encrypted with a password. This is needed in order to share federation information with other peers that the federation admin wants to invite to join the federation. The response will contain a token that can only be used once.
| <<fedml-api-join,Join an existing federation>> | This rest endpoint allows a peer to join an existing federation.
| <<fedml-api-start-pulse,Start Pulsing>> | This endpoint instructs your federation project to start `pulsing`, that is the project will periodically poll for messages from other nodes in the federation as well as sending its scheduled synchronization message.
| <<fedml-api-stop-pulse,Stop Pulsing>> | Stop synchronizing with the federation
| <<fedml-api-get-error-log,Get Error Log>> | Return the error log for this project. Since many messages between nodes happen asynchronously, this allows the user to see if there was an error while communicating with the other peers in the federation.
| <<fedml-api-get-sync-log,Get Sync Log>> | This returns a log of when this federated project was updated.
| <<fedml-api-get-aws-info,Get AWS Info>> | Return information about AWS SNS topic, SNS subscriptions as well as SQS queues. This is for troubleshooting purpose.
|==========

[[fedml-api]]
== Federated Learning API


[[fedml-api-create]]
=== Federated Learning Create Federation

[[url-fedml-create]]
==== URL
....
POST /symetry/rest/{cid}/fedml/create?pid={new-project-id} [body=Encrypted Map]
....

This REST endpoint allows the user to create a new federation. The user who creates the federation also becomes its administrator. The body is a map that is encoded to a JSON string and then encrypted using the user secret key. This encryption is necessary in order to protect sensitive information like _aws access key_ and _aws secret key_ that are required to be passed.

[[fedml-api-keymap]]
.Create Federation Body Key map value
[width="100%",cols="<15%,<15%,<67%",options="header",]
|=================
| Mandatory key | Required / Optional | Value Description
|*fed_name* | Required | The name of the federation.
|*fed_local_type* | Optional | The type of project to use. Supported values: `cpu` and `gpu`. The default value is `cpu`.
|*aws_access_key* | Required | Your AWS access key.
|*aws_secret_key* | Required | Your AWS secret key.
|*aws_region* | Required | The region to use to allocate resource needed by the federation (SNS topic, SQS queue and subscription).
| *s3_bucket* | Required | AWS S3 bucket to use to store message to other nodes in the federation.
|*aws_id* | optional | aws user id
|*sync_sched* | Required | The sync schedule, consult <<fedml-terminology>> for more details.
|=================

[[fedml-api-create-query-parameters]]
==== Query Parameters

[width="100%",cols="<25%,<25%,<50%",options="header",]
|=================
|Parameter |Required/Optional? |Description
|*pid* |Required | Name of the new SymetryML project.
|*persist* |Optional | whether to persist or not the project
|=================

[[fedml-api-create-responses]]
==== HTTP Responses

[width="100%",cols="<25%,<25%,<50%",options="header",]
|=================
|HTTP Status Code |HTTP Status Message |Description
|201 |CREATED |Success. +
`{"statusCode":"CREATED","statusString":" +
SYMETRYML Created with id:r1","values":{}}`
|409 |CONFLICT |SymetryML project already exists. +
`{"statusCode":"CONFLICT","statusString":" +
Customer [c1] already have SYMETRYML with id[r1], ","values":{}}`
|=================

[[fedml-api-create-response-entity]]
==== HTTP Response Entity

None

[[fedml-api-create-requestresponse]]
==== Sample Request/Response Fed Create
....
POST url="http://charm:8080/symetry/rest/c1/fedml/create?pid=nh_test_admin

Request Body:

KjxfT4/2TpJsfwd+gAG0zAnH7r+fs7IyKrlMXNoqh5CNQjoLioBW6HjXH5hRVqEYASueMI++fmMDAEOBIQD/e/3HDeA/SVojcmzywmxcMNotH9iTpboU9KIJZVq1JW3bxAv+e2COEuI+82qrQVJ4QifuAy5TxR+B5H0GjC0x4qiDK5h+TpEDnFB1Cjdv3xQyiDW8EetZNlCcriEdkTSvxI8duhdJIhFy4UYL1XzN7SavwmE/rddP+ETfeMmLJehseBOJr19xPiMR71maM2DybESQvCN1bWUj2XEvujasrcMMUK4+NEeC0pDe+gWoJhRgAZlRnOWgdwCKeBqcmqOc9Q==

Response:

{"statusCode":"CREATED","statusString":"Project Created with id:nh_test_admin","values":{}}
....

[[fedml-api-get-info]]
=== Federated Learning Get Federation Info

This rest call returns the information about the federation. The information is returned encrypted with the user secret key, that is the symetryml user key.

[[url-fedml-gi]]
==== URL
....
GET /symetry/rest/{cid}/fedml/{pid}/info
....

[[http-responses-fedml-gi]]
==== HTTP Responses

[width="100%",cols="<25%,<25%,<50%",options="header",]
|================================================================================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|400 |BAD REQUEST |SymetryML project does not exist. +
`{"statusCode":"BAD_REQUEST","statusString":"Cannot Find SYMETRYML id[r5] for Customer id [c1]","values":{}`
|================================================================================================================

[[http-response-entity-fedml-gi]]
==== HTTP Response Entity

[width="100%",cols="<25%,<75%",options="header",]
|===================================
|HTTP Response Entity |Description
|Encrypted FederationInfo +
(see <<federationinfo-json>>)
|See the example below.
|===================================

[[sample-requestresponse-fedml-gi]]
==== Sample Request/Response
....
Request:
GET url="http://charm:8080/symetry/rest/c1/fedml/nh_test_admin/info"

Response:
{"statusCode":"OK","statusString":"OK","values":{"fedInfoEncrypted":"mD3yV8TamG8BsXx/kGGqtnXm+O6njUfyKnH5U86fldQ7Lbsp0t6V5rAM7zhqtMaQsHPodR/5ATf5ovKTlnUSNkWQKkrbaQDR+rHnOymTcyfahXihXoccar67oE+VVYGJDQpDB7IOEVnKKzdFWqBxlHzLzGip0vFGcnfTXR3689oVB5BDbOSvsGkxfjRMoZBJLLVskN4yqmq+kbP5lrP+zuhR5NpTKCrPIe9phIiWlURzHb2RxsI6LHGhySz9iKytesYD4Kdl8iOzfffdx/jPDewreaks2Cx5RFobHPxfuBHYWHzLn2DISlxO+Pemg3Rq0FCZ7Hk9Fexps04yTxkk7S9iBDEWDufCK4cRIEYq1/feytV/Olv2a+OZDlpG38aHyk6uiYzpx22R8DJLoTjBW8Cp/JFgokyYdx29bM2MqlsfUSxIEulbfjoymdtu95PT4YjUelogTctAn9+/xnWiyrET3Fp9VqkCFnXuIdCm5udWspqr7sconMe1rgss5AMPbwqEAcabJR8rGl6zNQX6HgUOaIbKF7PpETMJvlLOby12uY0iljykqaZQNOTd1rjVmDXxxDlC7GcLinPpJE+WOGevGfrvcM71uIbDB1+a7Rz5QKvtW5X9RgL1rZtodXqiwpT1Br+THaKcrBnD45fG7EHBOwPNR4ue+uuvMi+57xLi1ntUIbPBJ7pzRZ09tkUCfh+aQvAbSoThna5Ef6XmTQ\u003d\u003d"}}

....


[[fedml-api-get-encrypted]]
=== Federated Learning Get Encrypted Federation Info

[[url-fedml-ge]]
==== URL
....
POST /symetry/rest/{cid}/fedml/{pid}/getEncrypted
....

.Get Encrypted Body Key Map Value 

TDB new ResponseEntityKey.

[width="100%",cols="<15%,<15%,<67%",options="header",]
|=================
| Mandatory key | Required / Optional | Value Description
|*passwd* | Required | Password to use to encrypt the federation information
|*fed_rest_host* | Required | Hostname where admin can be reach at.
|=================

[[http-responses-fedml-ge]]
==== HTTP Responses

[width="100%",cols="<25%,<25%,<50%",options="header",]
|================================================================================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|400 |BAD REQUEST |SymetryML project does not exist. +
`{"statusCode":"BAD_REQUEST","statusString":"Cannot Find SYMETRYML id[r5] for Customer id [c1]","values":{}`
|================================================================================================================

[[http-response-fedml-ge]]
==== HTTP Response Entity

The response will be stored in the `fedInfoEncrypted` entity which is a string. That string is in turn a json encoded string encrypted with the provided password. Once decrypted you get a <string, string> map that contains the following key: (Consult <<fedml-api-keymap>> for details). The response token `fed_req_token` can only be used one time.

* sync_sched 
* fed_name 
* fed_secret_key 
* aws_topic_arn 
* aws_topic_region 
* fed_req_token


[[sample-requestresponse-fedml-ge]]
==== Sample Request/Response
....
Request:
POST url="http://charm:8080/symetry/rest/c1/fedml/nh_test_admin/getEncrypted"

Request Body Before Encryption:
{"passwd":"passwd","fed_rest_host":"http://charm:8080"}

Request Body:
qvh4P1y937flTE/R6GgtrN8Weu28/jCx14zBIG5zk4CEqC4+rLL/HtVvKqUthPsSVZN8BgWP39O+MKEyOsUo8w==

Response: 
{"statusCode":"OK","statusString":"OK","values":{"fedInfoEncrypted":"ZwsCbdhP2GxfOgDBwJHoy61uRMZLNg7D581Cs9zWAgjwWpK2wScvgpTexpsVyilbvGThFVsWXz57n9BXY+DA1EmI+L29H+K60b1lI4v/WLr45HHCdMEDCcBAL+F3/3NcRBl5RcfgBlC4RTV6+h/75rr21lgMGxnVXlYBoUh//JpBxfJhEZyxa1gv0WVdCXDDT/M3Aq819r+6rS89jj38SYj/Hzj7pJaEHvbxe+OniH5Z90xEortLZeVdG8HE5zzqLegKpChFYFE4l60RXtdyE/fa7uY3gM7Q/yU+8SQ3Yjkvl8B5Gs7coBdgkcKNmcgiBqG4YrQSg8SCuX6RsKs4B4qV61w+AZkmt9+ipp049Hpxwu0myZ2agomcAMKdZHDv"}}
....

[[fedml-api-get-encrypted-rez]]
==== Decrypted Message Example:

Once decrypted the Federation info will contains infomation like in the following example. This is basically a hashap with a few key/ value pair. These key value pairs must be used when joining a federation. See <<fedml-api-join-required>> for details.
....
Decrypted JSON:
{
    "sync_sched":"m1",
    "fed_rest_url":"http://charm:8080/symetry/rest/c1/fedml/nh_test_admin/createPolicies",
    "fed_name":"nh_test_doc",
    "fed_secret_key":"t6Zat/ZAJyYBtmVXATUDCQ\u003d\u003d",
    "aws_topic_arn":"arn:aws:sns:us-east-1:428117700962:nh_test_doc",
    "aws_topic_region":"US_EAST_1",
    "fed_req_token":"FEDTOKEN38f45fe16545e80c",
}
....

[[fedml-api-join]]
=== Federated Learning Join a Federation

[[fedml-api-join-url]]
==== URL
....
POST /symetry/rest/{cid}/fedml/createJoin?pid={new-project-id} [body=Encrypted Map]
....

This REST endpoint allows the user to join an existing federation.  The body is a map that is encoded to a JSON string and then encrypted using the user secret key. This encryption is necessary in order to protect sensitive information like _aws access key_ and _aws secret key_ that are required to be passed as part of the body.


[[fedml-api-join-requestbody]]
==== Federation Join Request Body

The request body is composed of 2 types of key/value pairs:

* Those that come from the Admin in an encrypted form. See <<fedml-api-get-encrypted-rez>>
** <<fedml-api-join-required>>
* Those that relates to the new node to be created.
** <<fedml-api-join-body-keyval>>


[[fedml-api-join-required]]
===== Mandatory Key / Value Pairs from Federation Admin
The following key value will be received as part of the password encrypted json message from the federation admin. They need to be added the the query body without modification.

.Join Federation Body Key/Value Required From Admin
[width="100%",cols="<30%,<67%",options="header",]
|=================
| Mandatory key | Value Description
| *sync_sched* | use value from map received from federation admin
| *fed_secret_key* | use value from map received from federation admin
| *aws_topic_arn* | use value from map received from federation admin
| *fed_name* | use value from map received from federation admin
| *topic_region* | use value from map received from federation admin
| *fed_rest_url* | use value from map received from federation admin
| *fed_req_token* | use value from map received from federation admin
|=================

[[fedml-api-join-body-keyval]]
===== Request Body Key / Value Pairs
Additional key / value pairs are needed in the request body

.Join Federation Body Key map value
[width="100%",cols="<15%,<15%,<67%",options="header",]
|=================
| Mandatory key | Required / Optional | Value Description
| *fed_local_type* | Optional | The type of project to use. Supported values: `cpu` and `gpu`. The default value is `cpu`.
| *aws_access_key* | Required | 
| *aws_secret_key* | Required | 
| *aws_region* | Required | AWS Region to use.
| *aws_id* | Required | AWS ID. This is needed so that the federation admin can give a new node publish and subscribe rights.
| *s3_bucket* | Required | AWS S3 bucket. This is used to store messages for other nodes in the federation.
|=================

[[fedml-api-join-query-parameters]]
==== Query Parameters

[width="100%",cols="<25%,<25%,<50%",options="header",]
|=================
|Parameter |Required/Optional? |Description
|*persist* |Optional | Whether or not to persist the project. Defaults to true.
|*pid* |Optional | Project name
|=================

[[fedml-api-join-responses]]
==== HTTP Responses

[width="100%",cols="<25%,<25%,<50%",options="header",]
|=================
|HTTP Status Code |HTTP Status Message |Description
|201 |CREATED |Success. +
`{"statusCode":"CREATED","statusString":" +
Fed Project created with join","values":{}}`
|409 |CONFLICT |SymetryML project already exists. +
`{"statusCode":"CONFLICT","statusString":" +
Customer [c1] already have SYMETRYML with id[r1], ","values":{}}`
|=================

[[fedml-api-join-response-entity]]
==== HTTP Response Entity

None

[[fedml-api-join-requestresponse]]
==== Sample Request/Response Fed Create Join
....
POST url="http://charm:8080/symetry/rest/c1/fedml/createJoin?pid=node1"

Request Body:
KjxfT4/2TpJsfwd+gAG0zAnH7r+fs7IyKrlMXNoqh5CNQjoLioBW6HjXH5hRVqEYASueMI++fmMDAEOBIQD/e/3HDeA/SVojcmzywmxcMNotH9iTpboU9KIJZVq1JW3bxAv+e2COEuI+82qrQVJ4QifuAy5TxR+B5H0GjC0x4qiDK5h+TpEDnFB1Cjdv3xQycXSud7eRwy72gtY+wi8Rey3Ku1BerIRbhRVTBaHicb2duiZTZivdx1VJKA7BbH2s...


Response:
{"statusCode":"CREATED","statusString":"Fed Project created with join","values":{}}
....

[[fedml-api-start-pulse]]
=== Federated Learning: Start Pulse

Instruct the federation project to start syncing with other nodes in the federation.

[[fedml-api-start-pulse-url]]
==== URL
....
GET /symetry/rest/{cid}/fedml/{pid}/startPulse
....

[[fedml-api-start-pulse-response]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|==================================================


[[fedml-api-stop-pulse]]
=== Federated Learning: Start Pulse

Instruct the federation project to stop syncing with other nodes in the federation.

[[fedml-api-stop-pulse-url]]
==== URL
....
GET /symetry/rest/{cid}/fedml/{pid}/stopPulse
....

[[fedml-api-stop-pulse-response]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|==================================================

[[fedml-api-get-error-log]]
=== Federated Learning: Get Error Log

Return Error logging messages. For federated project many 'things' can happen in the background some of which that might cause error (invalid AWS credential, invalid S3 bucket path for examples. This some 
rest endpoint allows to check for various error that might occurs in asynchronously in the background.

[[fedml-api-get-error-log-url]]
==== URL
....
GET /symetry/rest/{cid}/fedml/{pid}/getErrorLog
....

[[fedml-api-get-error-log-response]]
==== HTTP Responses


[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|==================================================

[[fedml-api-get-error-log-entity]]
==== HTTP Response Entity

[width="100%",cols="<25%,<75%",options="header",]
|==================
|HTTP Response Entity |Example
| <<stringlist-json>> | `TBD`
|==================


[[fedml-api-get-error-log-example]]
==== Sample Request/Response Fed Create
....
GET url="http://charm:8080/symetry/rest/c1/fedml/kkg-node1/getErrorLog"

Response:
TBD
....

[[fedml-api-get-sync-log]]
=== Federated Learning: Get Sync Log

Return synchronization logging messages. TBD

[[fedml-api-get-sync-log-url]]
==== URL
....
GET /symetry/rest/{cid}/fedml/{pid}/getSyncLog
....

[[fedml-api-get-sync-log-response]]
==== HTTP Responses


[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|==================================================

[[fedml-api-get-sync-log-entity]]
==== HTTP Response Entity

[width="100%",cols="<25%,<75%",options="header",]
|==================
|HTTP Response Entity | Example
| <<stringlist-json>> | `TBD`
|==================


[[fedml-api-get-sync-log-example]]
==== Sample Request/Response Fed Create - Bad S3 bucket
....
GET url="http://charm:8080/symetry/rest/c1/fedml/kkg-node1/getErrorLog"

Response:
{"statusCode":"OK","statusString":"OK","values":{"stringList":["com.amazonaws.services.s3.model.AmazonS3Exception: Access Denied (Service: Amazon S3; Status Code: 403; Error Code: AccessDenied; Request ID: BECB121F96D0DA27; S3 Extended Request ID: iSi3fe/l6B8pTtVx4dovZ4OM/5PwDRRbEmpzoZaylnL3SuFibSrnMY1LkwMFpjUaO6LouBJEu1g\u003d), S3 Extended Request ID: iSi3fe/l6B8pTtVx4dovZ4OM/5PwDRRbEmpzoZaylnL3SuFibSrnMY1LkwMFpjUaO6LouBJEu1g\u003d"]}}
....

[[fedml-api-get-aws-info]]
=== Federated Learning: Get AWS Info

This rest endpoint is provided so that one can inspect the
AWS resources utilized by the federation.

[[fedml-api-get-aws-info-url]]
==== URL
....
POST /symetry/rest/{cid}/fedml/{pid}/awsinfo [body=Encrypted Map]
....

[[fedml-api-get-aws-info-body]]
==== Request Body Map Keys

[width="100%", cols="<30%,<69%",options="header",]
|==================================================
| Key |Description
| *aws_access_key*  | Required
| *aws_secret_key*  | Required
| *aws_region*  | Optional, if not passed, result will be returned for all aws region
|==================================================


[[fedml-api-get-aws-info-response]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|==================================================

[[fedml-api-get-aws-info-entity]]
==== HTTP Response Entity

[width="100%",cols="<25%,<75%",options="header",]
|==================
|HTTP Response Entity |Example
| <<awsinfo-json>> | Please consult the <<awsinfo-json>> for an example. The response will be an encrypted JSON string. The entity key will be `awsInfoEncrypted`.
|==================


[[fedml-api-get-aws-info-entity-requestresponse]]
==== Sample Request/Response
....
Request
POST url="http://charm:8080/symetry/rest/c1/fedml/awsinfo"

Response Header:
Location: http://charm:8080/symetry/rest/c1/jobs/4

Response:
{"statusCode":"ACCEPTED","statusString":"Job Created","values":{}}

Job Request:
GET url="http://charm:8080/symetry/rest/c1/jobs/4
....

[[exploration-api]]
== Exploration API


[[about-the-exploration-api]]
=== About the Exploration API

The Exploration API allows for the request of statistical metrics of SymetryML projects using univariate, bivariate, Hypothesis Testing (ztest, test, ftest, ANOVA) as well as Information Gain analyses. The body of the request contains a  <<explorecontext-json>> which in turn is a list of <<mlcontext-json>>, one for each feature for which exploration data is needed.

[[exploration-api-url]]
==== URL
....
POST /symetry/rest/{cid}/projects/{pid}/explore?metric={_metric_} [body=ExploreContext]
....
[[exploration-api-query-parameters]]
==== Query Parameters

[width="100%", cols="<25%,<25%,<50%",options="header",]
|===========================================================================================================================
|Parameter |Required/Optional? |Description
|metric |Required |Metric to use for exploration. For more information, see the section <<list-of-metric-query-parameters>>
|===========================================================================================================================

[[exploration-api-http-responses]]
==== HTTP Responses

[width="100%",cols="<25%,<25%,<50%",options="header",]
|===============================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|400 |BAD REQUEST |Unknown SymetryML project. +
`{"statusCode":"BAD_REQUEST","statusString":"
Cannot Find SYMETRYML id[r2] for Customer id [c1]","values":{}}`
|===============================================================

[[exploration-api-http-response-entity]]
==== HTTP Response Entity

The response is a KSVDMap entity. This structure is an array of map<key,value>, where keys are string and values are an Institute of Electrical and Electronics Engineers (IEEE) 64-bit double floating-point number. One such map is added to the response for each <<mlcontext-json>> in the ExploreContext request body. The keys in each map depend on the metric query parameter. For more information, see the section <<explorecontext-json>>.

[width="100%",cols="<25%,<75%",options="header",]
|====================
|HTTP Response Entity |Example
|KSVDMap +
(see <<ksvsmap-json>>)
|`{"statusCode":"OK","statusString":"OK","values":{"KSVDMap":{"values":[{"count":150.0,"mean":5.843333333333334,"variance":0.6811222222222204,"skewness":0.31808651443435426,"stddev":0.8253012917851398}]}}}`
|smlInfo +
see <<projectinfo-json>> | A project info entity is also returned to reflect the state of the project that might have changed.
|====================


[[list-of-metric-query-parameters]]
=== List of "Metric" Query Parameters

Depending on the metric query parameter, different information is returned in the KSVDMap JSON response entity. The KSVDMap JSON entity is an array of map<key, value>, where key is a string and value is an IEEE 64-bit double floating-point number. The following table enumerates the keys that the response will contain for all valid metric query parameters.

.Keys Contained by Responses
[width="100%",cols="<10%,<40%,<50%",options="header",]
|==============
|Metric |Description |KSVDMap Key
|*uni* |Returns all univariate metrics for the attribute listed in each MLContext in the ExploreContext. If an MLContext has more than one attribute, only the first one is used.|
            - *count* = count of the attribute. +
            - *Mean* = mean of the attribute. +
            - *variance* = variance of the attribute. +
            - *stddev* = standard deviation of the attribute. +
            - *skewness* = skewness of the attribute.
|*bi* |Returns all bivariate metrics for the two attributes listed in each MLContext in the ExploreContext. Each MLContext should contain at least two attribute indexes. If there are more than two, only the first two are used. |
            - *covar* = covariance between the two attributes. +
            - *linCorr* = linear correlation between the two attributes. +
            - *condMean* = conditional mean +
            - *condCount* = conditional count +
            - *condVariance* = conditional variance
|*ztest* |Returns the z-test metrics using all of the MLContext in the ExploreContext request body. |
            - *zn1* = count between attribute and target 1. +
            - *zn2* = count between attribute and target 2. +
            - *zm1* = mean between attribute and target 1. +
            - *zm2* = mean between attribute and target 2. +
            - *zs1* = variance between attribute and target 1. +
            - *zs2* = variance between attribute and target 2. +
            - *z* = z test value. +
            - *zp* = z test value probability.
|*ztestp* |Returns the z-test-proportion metrics using all of the MLContext in the ExploreContext request body. |
            - *z* = z test value. +
            - *zp* = z test value probability.
|*ztestmu* |Returns the z-test - against a known mean - metrics using all of the MLContext in the ExploreContext request body. |
            - *z* = z test value. +
            - *zp* = z test value probability.
|*ftest* |Returns the f-test metrics using all of the MLContext in the ExploreContext request body. |
            - *fn1* = count between attribute and target 1. +
            - *fn2* = count between attribute and target 2. +
            - *fm1* = mean between attribute and target 1. +
            - *fm2* = mean between attribute and target 2. +
            - *fs1* = variance between attribute and target 1. +
            - *fs2* = variance between attribute and target 2. +
            - *fdf1* = degree of freedom between attribute and target 1. +
            - *fdf2* = degree of freedom between attribute and target 2. +
            - *f* = F test value. +
            - *fp* = F test value probability.
|*ftestmu* |Returns the f-test - against a known variance - metrics using all of the MLContext in the ExploreContext request body. |
            - *f* = F test value. +
            - *fp* = F test value probability.
|*ttest* |Returns the t-test metrics using all of the MLContext in the ExploreContext request body. |
            - *tn1* = count between attribute and target 1. +
            - *tn2* = count between attribute and target 2. +
            - *tm1* = mean between attribute and target 1. +
            - *tm2* = mean between attribute and target 2. +
            - *ts1* = variance between attribute and target 1. +
            - *ts2* = variance between attribute and target 2. +
            - *t* = t test value. +
            - *tdf* = t test value degree of freedom. +
            - *tp* = t test value probability. +
            - *tu* = t test value for unequal variance. +
            - *tdfu* = t test value degree of freedom for unequal variance. +
            - *tpu* = t test value probability for unequal variance.
|*ttestmu* |Returns the T-test - against a known mean - metrics using all of the MLContext in the ExploreContext request body. |
            - *t* = T test value. +
            - *tp* = T test value probability.
|*anova* |Returns the ANOVA metrics using all of the MLContext in the ExploreContext request body. |
            - *SSb* = sum square between groups. +
            - *SSw* = sum square within groups. +
            - *Dfb* = degree of freedom between groups. +
            - *Dfw* = degree of freedom within groups. +
            - *MSb* = mean square between groups. +
            - *MSw* = mean square within groups. +
            - *F* = F value from F distribution. +
            - *Ssgamma* = total sum of square. +
            - *Dfgamma** = total degree of freedom. +
            - *P* = probability of F.
|*chi2* |Returns chi-square information using all of the MLContext in the ExploreContext request body. |
            - *chiStat* = chi-square value. +
            - *df* = degree of freedom. +
            - *pval* = probability. +
            - *coef* = contingency coefficient. +
            Additionally, for all the pair wise values the observed count will be returned as a value using the following format for the key. +
            *_obs${row_index}:{col_index}_* +
            Example: +
            *obs$1:4*
|*gain* |Returns information gain for a given attribute –input - given another attributes – target. |
|==============

Note *ztestmu*, *ttestmu*, and *ftestsima* require the following parameters to be set in `MLContext.extraParameters` respectively: *sml.explore.ztest.known_mu*, *sml.explore.ttest.known_mu*, and *sml.explore.ftest.known_sigma*.

[[various-hyp-testing]]
=== Various Hypothesis Test

Its possible to perform _variations_ on ztest, ftest, ttest, anova, and chi-squared test. Depending on which test needs to be performed the <<mlcontext-json>> must be populated differently.

.Hypothesis Testing Suite
[width="100%",cols="<40%,<60%",options="header",]
|======================
|Hypothesis Test | MLContext Content
| *Z test* Compare means of 2 continuous features. 
| `inputAttributes`: contains 2 continuous attributes ids
| *Z test*  Compare mean of 1 continuous feature against a known mean 
| * `inputAttributes`: contains 1 continuous attribute id +
 * `extraParameters`: contains one key `sml.explore.ztest.known_mu` with known mean
| *Z test*  Compare means of a continuous feature conditioned on 2 binary features 
| `inputAttributes`: contains 3 attribute id, first one is continuous followed by 2 binary ids
| *Z test proportion*  Compare two proportions originated from two binary features
| `inputAttributes`: contains 2 binary attribute id
| *F test* Compare variance of 2 continuous features.
| `inputAttributes`: contains 2 continuous attributes id
| *F test* Compare variance of continuous feature against a known variance 
| * `inputAttributes`: contains 1 continuous attribute id +
* `extraParameters`: contains one key `sml.explore.ftest.known_sigma` with known variance / sigma
| *F test* Compare  variances of a continuous feature conditioned on 2 binary features 
| `inputAttributes`: contains 3 attribute id, first one is continuous followed by 2 binary ids
| *T test* Compare means of 2 continuous features. 
| `inputAttributes`: contains 2 continuous attributes id
| *T test* Compare mean of 1 continuous feature against a known mean 
| * `inputAttributes`: contains 1 continuous attribute id +
* `extraParameters`: contains one key `sml.explore.ttest.known_mu` with known mean
| *T test* Compare  means of a continuous feature conditioned on 2 binary features 
| `inputAttributes`: contains 3 attribute id, first one is continuous followed by 2 binary ids
| *Anova* Compare means of 2 or more continuous features 
| `inputAttributes`: contains 2 or more continuous attribute id
| *Anova* Compare means of a continuous feature conditioned on 2 or more binary features 
| * `inputAttributes`: contains 1 continuous attribute id +
* `targets`: contains 1 or more binary attribute id
| *Chi square* Determine the association between binary features.
| *`inputAttributes`: contains 2 or more binary attribute ids +
* `targets`: contains 2 or more binary attribute ids +
see <<exploration-api-ex-2>> for example.
| *Chi square* Determine the association between binary features based on category names
| `inputAttributes`: list of category name+
See <<exploration-api-ex-3>> for example.
|======================



[[exploration-api-ex-1]]
==== Sample Request/Response Bivariate Statistics
....
Request:
POST url="http://charm:8080/symetry/rest/c1/projects/irisTest/explore?metric=bi"

Body:
{"values":[{"targets":[],"inputAttributes":["0","3"],"extraParameters":{}}]}

Response:
{"statusCode":"OK","statusString":"OK","values":{"smlInfo":{"pid":"r1","isDirty":true,"modelsList":[],"modelTypeList":[],"attributeNames":["sepal_length","sepal_width","petal_length","petal_width","sepal_lengt_b1","sepal_lengt_b2","sepal_width_b1","sepal_width_b2","petal_length_b1","petal_length_b2","petal_width_b1","petal_width_b2","Iris_setosa","Iris_versicolor","Iris_virginica"],"attributeIndexes":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14],"attributeTypes":["C","C","C","C","B","B","B","B","B","B","B","B","B","B","B"],"modelAssessments":{},"modelPredictions":{},"hash":-1,"categorySeparator":"$","type":"cpu","creationDate":1488220762857,"lastModificationDate":1488220780484,"loaded":true,"persisted":true},"KSVDMap":{"values":[{"linCorr":0.8180000000000001,"condVariance":30.9294,"covar":0.5135000000000001,"condCount":179.8,"condMean":6.2717}]}}}

....


[[exploration-api-ex-2]]
==== Sample Request/Response chi2 Example 1
....
Request:
POST url="http://charm:8080/symetry/rest/c1/projects/irisTest/explore?metric=chi2"

Body:
{"values":[{"targets":["12","13","14"],"inputAttributes":["10","11"],"inputAttributeNames":[],"extraParameters":{}}]}

Response:
{"statusCode":"OK","statusString":"OK","values":{"smlInfo":{"pid":"irisP","isDirty":true,"modelsList":[],"modelTypeList":[],"dsList":["Iris_rtlm.csv"],"attributeNames":["sepal_length","sepal_width","petal_length","petal_width","sepal_lengt_b1","sepal_lengt_b2","sepal_width_b1","sepal_width_b2","petal_length_b1","petal_length_b2","petal_width_b1","petal_width_b2","Iris_setosa","Iris_versicolor","Iris_virginica"],"attributeIndexes":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14],"attributeTypes":["C","C","C","C","B","B","B","B","B","B","B","B","B","B","B"],"modelAssessments":{},"modelPredictions":{},"params":{},"hash":-1,"categorySeparator":"$","type":"cpu","creationDate":1588623147023,"lastModificationDate":1588623148044,"loaded":true,"persisted":true,"histogramEnabled":true},"KSVDMap":{"values":[{"df":2.0,"obs$11:12":0.0,"coef":0.8409000000000001,"pval":0.0,"chiStat":150.0,"obs$10:14":0.0,"obs$10:13":0.0,"obs$10:12":50.0,"obs$11:13":50.0,"obs$11:14":50.0}]}}}

....


[[exploration-api-ex-3]]
==== Sample Request/Response chi2 Example 2
....
Request:
POST url="http://charm:8080/symetry/rest/c1/projects/dice/explore?metric=chi2"

Body:
{"values":[{"targets":[],"inputAttributes":["d1","d2","d3","d4","d5"],"inputAttributeNames":[],"extraParameters":{}}]}


Response:
{"statusCode":"OK","statusString":"OK","values":{"smlInfo":{"pid":"dicep","isDirty":true,"modelsList":[],"modelTypeList":[],"dsList":["dice5.csv"],"attributeNames":["d1$1","d1$5","d1$6","d1$3","d1$4","d1$2","d2$3","d2$2","d2$5","d2$6","d2$4","d2$1","d3$2","d3$1","d3$6","d3$4","d3$3","d3$5","d4$5","d4$2","d4$3","d4$6","d4$4","d4$1","d5$1","d5$2","d5$3","d5$4","d5$6","d5$5"],"attributeIndexes":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29],"attributeTypes":["B","B","B","B","B","B","B","B","B","B","B","B","B","B","B","B","B","B","B","B","B","B","B","B","B","B","B","B","B","B"],"modelAssessments":{},"modelPredictions":{},"params":{},"hash":-1,"categorySeparator":"$","type":"cpu","creationDate":1589219373647,"lastModificationDate":1589219374612,"loaded":true,"persisted":true,"histogramEnabled":false},"KSVDMap":{"values":[{"obs$d1:4":174.0,"obs$d2:3":180.0,"obs$d3:2":179.0,"obs$d4:2":155.0,"obs$d5:1":169.0,"obs$d1:3":156.0,"obs$d2:2":162.0,"obs$d3:1":175.0,"obs$d4:3":179.0,"obs$d5:2":172.0,"obs$d1:2":161.0,"obs$d2:1":145.0,"obs$d4:4":196.0,"obs$d5:3":164.0,"df":20.0,"obs$d1:1":182.0,"obs$d4:5":166.0,"obs$d5:4":177.0,"obs$d3:6":155.0,"obs$d2:6":178.0,"obs$d3:5":174.0,"pval":0.20470000000000002,"obs$d1:6":149.0,"obs$d2:5":141.0,"obs$d3:4":168.0,"obs$d1:5":178.0,"obs$d2:4":194.0,"obs$d3:3":149.0,"obs$d4:1":158.0,"obs$d4:6":146.0,"obs$d5:5":156.0,"obs$d5:6":162.0,"coef":0.0334,"chiStat":24.9148}]}}}

....



[[pca-exploration]]
=== PCA Exploration

This REST endpoint allows for the request of the principal component analysis (PCA) of a set of attributes.

This API function is asynchronous. If it succeeds, it returns a 202 response, along with a Location header that specifies the job URL. For more information about SymetryML asynchronous job please refer the section <<symetryml-job-information>>.

[[url-18]]
==== URL
....
POST /symetry/rest/{cid}/projects/{pid}/explorepca?explainedCovariance [body=ExploreContext]
....
[[query-parameters-7]]
==== Query Parameters

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==============
|Parameter |Required/Optional? |Description
|explainedCovariance |Optional |This parameter controls how many Eigen vectors/values will be returned in term of explained covariance. Default is 1 which correspond to 100% of explained covariance. Note that in order to avoid sending too much large response body, the maximum number of Eigen values/vectors that will be returned is 100.
|==============

[[http-responses-18]]
==== HTTP Responses

[width="100%",cols="<25%,<25%,<50%",options="header",]
|===============================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|400 |BAD REQUEST |Unknown SymetryML project.
`{"statusCode":"BAD_REQUEST","statusString":" +
Cannot Find SYMETRYML id[r2] for Customer id [c1]","values":{}}`
|===============================================================

[[http-response-entity-18]]
==== HTTP Response Entity

The response contains three keys:

* pcaVectors
* pcaValues
* pcaSumValues

The value for the pcaVectors and pcaValues keys is a Matrix stored in a DataFrame JSON data structure. The pcaSumValues key consists of a number that is the sum of all the Eigen values. See <<dataframe-json>> for information on the DataFrame JSON structure.

[width="100%", cols="<25%,<75%",options="header",]
|===========
|HTTP Response Entity |Example
|pcaVectors |A DataFrame containing the PCA vectors (see <<dataframe-json>>).
|pcaValues |A DataFrame containing the PCA values (<<dataframe-json>>).
|pcaSumValues |A number representing the total sum of the PCA values. You can use that number to compute the % of covariance explained by a given Eigen vectors.
|===========

[[sample-requestresponse-13]]
==== Sample Request/Response
....
Request:
POST url="http://charm:8080/symetry/rest/c1/projects/irisTest/explorepca"

Body:
{"values":[{"targets":[],"inputAttributes":["2","4"]}]}

Response Header:
Location: http://charm:8080/symetry/rest/c1/jobs/4

Response:
{"statusCode":"ACCEPTED","statusString":"Job Created","values":{}}

Job Request:
GET url="http://charm:8080/symetry/rest/c1/jobs/4

Job Response:
{pcaVectors, pcaValues, pcaSumValues}
....

[[svd-exploration]]
=== SVD Exploration

This REST endpoint allows to get the singular values decomposition (SVD) of a set of attributes.

This API function is asynchronous. If it succeeds, it returns a 202 response, along with a Location header that specifies the job URL. For more information about SymetryML asynchronous job please refer the section <<symetryml-job-information>>.

The request body needs to contains the list of input attributes id to be used while computing the singular value decomposition. Refer to section <<explorecontext-json>> for details.

[[url-19-1]]
==== URL
....
POST /symetry/rest/{cid}/projects/{pid}/exploresvd [body=ExploreContext]
....
[[http-responses-19-1]]
==== HTTP Responses

[width="100%",cols="<25%,<25%,<50%",options="header",]
|===============================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|400 |BAD REQUEST |Unknown SymetryML project.
`{"statusCode":"BAD_REQUEST","statusString":" +
Cannot Find SYMETRYML id[r2] for Customer id [c1]","values":{}}`
|===============================================================

[[http-response-entity-19-1]]
==== HTTP Response Entity

[width="100%",cols="<25%,<75%",options="header",]
|===========================================================================================
|HTTP Response Entity |Example
|KSVSMap +
(see <<ksvsmap-json>>)
|A map<String, String> map containing singular values along their attributes names. Each key/value pair in the result map contains: +
*key* = a SVD computed number, that is a singular value +
*value* = The name of the attribute
|===========================================================================================

[[sample-requestresponse-14]]
==== Sample Request/Response
....
Request:
POST url="http://charm:8080/symetry/rest/c1/projects/irisTest/exploresvd"

Body:
{"values":[{"targets":[],"inputAttributes":["2","4", "3", "5"]}]}

Response Header:
Location: http://charm:8080/symetry/rest/c1/jobs/4

Response:
{"statusCode":"ACCEPTED","statusString":"Job Created","values":{}}

Job Request:
GET url="http://charm:8080/symetry/rest/c1/jobs/4

Job Response:
KSVSMAP{}
....


[[svd-exploration-fs]]
=== SVD Features Selection

This REST endpoint allows to use singular value decomposition to perform feature selection. This endpoint will return a subset of attributes that are not singular based on the SVD algorithms. The SVD algorithms might be used multiple time internally to eventually reach the solution.

This API function is asynchronous. If it succeeds, it returns a 202 response, along with a Location header that specifies the job URL. For more information about SymetryML asynchronous job please refer the section <<symetryml-job-information>>.

The request body needs to contains the list of input attributes id to be used while computing the singular value decomposition. Refer to section <<explorecontext-json>> for details.

[[url-19-2]]
==== URL
....
POST /symetry/rest/{cid}/projects/{pid}/exploresvdfs [body=ExploreContext]
....
[[http-responses-19-2]]
==== HTTP Responses

[width="100%",cols="<25%,<25%,<50%",options="header",]
|=============================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|400 |BAD REQUEST |Unknown SymetryML project.
`{"statusCode":"BAD_REQUEST","statusString":" +
Cannot Find SYMETRYML id[r2] for Customer id [c1]","values":{}}`
|=============================

[[http-response-entity-19-2]]
==== HTTP Response Entity

[width="100%",cols="<25%,<75%",options="header",]
|=============================
|HTTP Response Entity |Example
|KSVSMap +
(see <<ksvsmap-json>>)
|A map<String, String> map containing singular values along their attributes names. Each key/value pair in the result map contains: +
*key* = a SVD computed number, that is a singular value +
*value* = The name of the attribute
|=============================


[[density-estimate]]
=== Density Estimates

This method returns the density estimate / histogram for any `continuous` or `binary` attributes in your SymetryML project. Histogram building must have been enabled - for the wanted symetry project - before invoking this rest endpoint. Histogram building for a project can be enabled by 2 means:

* When creating the project with the `enableHistogram` query parameter. See <<query-parameters-1>>
* Explicitly invoking the <<histogram-enable>> rest endpoint on any given project.


[[density-estimate-url]]
==== URL
....
POST /symetry/rest/{cid}/projects/{pid}/densityEstimate [body=ExploreContext]
....

[[density-estimate-mlcontext]]
==== MLContext Parameters for Density Estimates

For each features / attributes for which histogram are requested a <<mlcontext-json>> is needed inside the <<explorecontext-json>>. The following tables describes the extra parameters can be used:

[width="100%", cols="<25%,<25%,<50%",options="header",]
|===========================================================================================================================
| Parameter | Required / Optional ? | Description
| hist.bins | Required | Number of bins in the histogram
| hist.max | Optional | Minimum value of the histogram on the x axis
| hist.min | Optional | Maximum value of the histogram on the x axis
| hist.is.normalized | Optional | normalize the histogram in percentage insttead of using absolute value.
| hist.use.subsampling | Optional - Default is true | A boolean that specify to use a subsample of the data to compute histogram. This is done so that computation is more efficient. If one need the full histogram pass false.
|===========================================================================================================================


[[density-estimate-http-responses]]
==== HTTP Responses

[width="100%",cols="<25%,<25%,<50%",options="header",]
|===============================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|400 |BAD REQUEST |Unknown SymetryML project.
`{"statusCode":"BAD_REQUEST","statusString":" +
Cannot Find SYMETRYML id[r2] for Customer id [c1]","values":{}}`
|===============================================================

[[density-estimate-http-response-entity]]
==== HTTP Response Entity

[width="100%",cols="<25%,<75%",options="header",]
|=================
|HTTP Response Entity |Example
| <<densitylist-json>> | see <<density-estimate-sample-requestresponse>> below
|=================

[[density-estimate-sample-requestresponse]]
==== Sample Request/Response
....
Request:
POST url="http://charm:8080/symetry/rest/c1/projects/irisTest/densityEstimate"

Body:
{"values":[{"inputAttributeNames":["sepal_length"],"inputAttributes":[],"targets":[],"extraParameters":{"hist.bins":"20"}},{"inputAttributeNames":["sepal_width"],"inputAttributes":[],"targets":[],"extraParameters":{"hist.bins":"20"}},{"inputAttributeNames":["petal_length"],"inputAttributes":[],"targets":[],"extraParameters":{"hist.bins":"20"}},{"inputAttributeNames":["petal_width"],"inputAttributes":[],"targets":[],"extraParameters":{"hist.bins":"20"}},{"inputAttributeNames":["sepal_lengt_b1"],"inputAttributes":[],"targets":[],"extraParameters":{"hist.bins":"2"}},{"inputAttributeNames":["sepal_lengt_b2"],"inputAttributes":[],"targets":[],"extraParameters":{"hist.bins":"2"}},{"inputAttributeNames":["sepal_width_b1"],"inputAttributes":[],"targets":[],"extraParameters":{"hist.bins":"2"}},{"inputAttributeNames":["sepal_width_b2"],"inputAttributes":[],"targets":[],"extraParameters":{"hist.bins":"2"}},{"inputAttributeNames":["petal_length_b1"],"inputAttributes":[],"targets":[],"extraParameters":{"hist.bins":"2"}},{"inputAttributeNames":["petal_length_b2"],"inputAttributes":[],"targets":[],"extraParameters":{"hist.bins":"2"}},{"inputAttributeNames":["petal_width_b1"],"inputAttributes":[],"targets":[],"extraParameters":{"hist.bins":"2"}},{"inputAttributeNames":["petal_width_b2"],"inputAttributes":[],"targets":[],"extraParameters":{"hist.bins":"2"}},{"inputAttributeNames":["Iris_setosa"],"inputAttributes":[],"targets":[],"extraParameters":{"hist.bins":"2"}},{"inputAttributeNames":["Iris_versicolor"],"inputAttributes":[],"targets":[],"extraParameters":{"hist.bins":"2"}},{"inputAttributeNames":["Iris_virginica"],"inputAttributes":[],"targets":[],"extraParameters":{"hist.bins":"2"}}]}


Response:
{"statusCode":"OK","statusString":"OK","values":{"densityList":{"values":[{"attrName":"sepal_length","min":4.3,"max":7.9,"width":0.18000000000000002,"histogram":[4.0,5.0,7.0,16.0,9.0,5.0,13.0,14.0,10.0,6.0,10.0,16.0,7.0,11.0,5.0,1.0,4.0,1.0,5.0,1.0]},{"attrName":"sepal_width","min":2.0,"max":4.4,"width":0.12000000000000002,"histogram":[1.0,3.0,4.0,3.0,8.0,14.0,14.0,10.0,26.0,12.0,19.0,12.0,6.0,3.0,9.0,2.0,1.0,1.0,1.0,1.0]},{"attrName":"petal_length","min":1.0,"max":6.9,"width":0.29500000000000004,"histogram":[4.0,33.0,11.0,2.0,0.0,0.0,1.0,2.0,3.0,5.0,12.0,14.0,12.0,17.0,6.0,12.0,7.0,4.0,2.0,3.0]},{"attrName":"petal_width","min":0.1,"max":2.5,"width":0.12,"histogram":[34.0,7.0,7.0,1.0,1.0,0.0,0.0,7.0,3.0,5.0,21.0,12.0,4.0,2.0,17.0,6.0,6.0,3.0,8.0,6.0]},{"attrName":"sepal_lengt_b1","min":0.0,"max":1.0,"width":0.5,"histogram":[67.0,83.0]},{"attrName":"sepal_lengt_b2","min":0.0,"max":1.0,"width":0.5,"histogram":[83.0,67.0]},{"attrName":"sepal_width_b1","min":0.0,"max":1.0,"width":0.5,"histogram":[93.0,57.0]},{"attrName":"sepal_width_b2","min":0.0,"max":1.0,"width":0.5,"histogram":[57.0,93.0]},{"attrName":"petal_length_b1","min":0.0,"max":1.0,"width":0.5,"histogram":[89.0,61.0]},{"attrName":"petal_length_b2","min":0.0,"max":1.0,"width":0.5,"histogram":[61.0,89.0]},{"attrName":"petal_width_b1","min":0.0,"max":1.0,"width":0.5,"histogram":[100.0,50.0]},{"attrName":"petal_width_b2","min":0.0,"max":1.0,"width":0.5,"histogram":[50.0,100.0]},{"attrName":"Iris_setosa","min":0.0,"max":1.0,"width":0.5,"histogram":[100.0,50.0]},{"attrName":"Iris_versicolor","min":0.0,"max":1.0,"width":0.5,"histogram":[100.0,50.0]},{"attrName":"Iris_virginica","min":0.0,"max":1.0,"width":0.5,"histogram":[100.0,50.0]}]}}}
....


[[modeling-api]]
== Modeling API


[[specific-model-building]]
=== Specific Model Building

This API function allows for the building of a model by specifying the attribute and the targets to use to build the model. The information about which attributes to use to build the model are passed as part of the body request in the MLContext JSON data structure. For more information see the next section <<mlcontext-build-parameters>>.

[[mlcontext-build-parameters]]
=== MLContext Build Parameters

When SymetryML builds new model it might use Matrix inversion. These operations are performed using an implementation of LAPACK (DGETRF and DGETRI) using some third party library using CPU and / or GPU. Matrix inversion can lead to numerical instability problem. Good news is that It's possible to fine tune the behavior of these LAPACK call using the following 2 parameters. Please consult online documentation for details on how to fine-tune these 2 parameters.

[width="100%", cols="<25%,<25%,<50%",options="header",]
|=============================
|Parameter |Type |Description
|*sml.rcond.use* |Boolean: ‘true’ or ‘false’ |Controls whether SymetryML conducts numerical instability (i.e., reciprocal condition number validation) when performing matrix inversion when building a model.
|*sml.rcond.tolerance* |Number |By default to the accepted tolerance for the reciprocal condition number validation is 1e-14. Using this parameter, you can set it to lower values. However, be sure you understand the implications and assess your model carefully, as you might get a numerically unstable model when modifying this value.
|*sml.explore.ztest.known_mu* | Number | This parameter is used to pass the _known variance_ when performing the _ztest_ against a known variable. 
|*sml.det.norm.use*  | boolean | This allows to avoid numerical instability when computing determinant of large matrix. Determinant are needed when building QDA model with <<about-partitioned-projects,partitioned projects>>. This parameter control how determinant is computed by using a sum of natural logarithms - instead of multiplication on the diagonal of the decomposed inverted matrix.
| *alpha* | Number | Alpha parameter when building a Ridge Regression model
| *matrix.use.pseudoinv* | boolean | Use matrix pseudo inverse algorithm - with SVD - when computing matrix inverse in model like MLR, LDA and QDA. 
|=============================

[[url-20]]
==== URL
....
POST /symetry/rest/{cid}/projects/{pid}/build?modelid={modelid}&algo={algorithm} [body=MLContext]
....

[[query-parameters-8]]
==== Query Parameters

[width="100%", cols="<25%,<25%,<50%",options="header",]
|=============================
|Parameter |Required/Optional? |Description
|modelid |Required |ID to assign to the new model.
|algo |Required |Algorithm to use to build the model. See Model Algorithm Id.
|svdreduce |Optional |Use SVD feature selection
|=============================

[[http-responses-20]]
==== HTTP Responses

[width="100%",cols="<25%,<25%,<50%",options="header",]
|=============================
|HTTP Status Code |HTTP Status Message |Description
|202 |ACCEPTED |Success. Includes an HTTP Location header specifying the location of the job ID that was created to handle the request.
`{"statusCode":"ACCEPTED","statusString":"Job Created","values":{}}`
|500 |INTERNAL SERVER ERROR |If the server refuses to accept the new job, it notifies the client with the error "Job execution was refused by server."
|=============================

[[model-algorithm-id]]
===== Model Algorithm Id

[width="100%", cols="<25%,<75%",options="header",]
|======================================
|Id |Algorithm
|*lda* |LDA, Linear Discriminant
|*mlda* |Multi-class LDA, Linear Discriminant
|*lsvm* |Linear SVM
|*lsvr* |Linear Support Vector Regression
|*mqda* |Quadratic discriminant Analysis
|*mlr* |Multi Linear Regression
|*bayes* |Bayesian Model
|*mc* |Markov Chains
|*hmm* |Hidden Markov Chains
|*ridge* |Ridge Regression
|======================================

[[http-response-entity-20]]
==== HTTP Response Entity

None

[[sample-requestresponse-15]]
==== Sample Request/Response
....
Request:
POST url="http://charm:8080/symetry/rest/c1/projects/irisTest/build?algo=lda&modelid=testLDA"

Body:
{"targets":["3"],"inputAttributes":["0","1","2"]}

Response Header:
Location: http://charm:8080/symetry/rest/c1/jobs/5

Response:
{"statusCode":"ACCEPTED","statusString":"Job Created","values":{}}

Job Request:
GET url="http://charm:8080/symetry/rest/c1/jobs/5

Job Response:
{"statusCode":"OK","statusString":"Job is finished","values":{}}
....

[[optimized-model-building]]
=== Features Reduction Model Building

This API function allows for the building of an optimized model (aka reduced models), where the SymetryML service builds a model using the best attributes for the target specified in the MLContext of the request body. Like the model-building request, the response contains a Location header for the job that was created to service this request. Information about these jobs can be requested and are described in the <<symetryml-job-information>> chapter.

[[url-21]]
==== URL
....
POST /symetry/rest/{cid}/projects/{pid}/reduce?heuristic={heuristic}&modelid={modelid}&algo={algorithm}&delta [body=MLContext]
....
[[query-parameters-9]]
==== Query Parameters

[width="100%", cols="<25%,<25%,<50%",options="header",]
|============================================================================================
| Parameter | Required/Optional? | Description
| Heuristic | Required | Used when optimizing the model. Currently, only "default" is supported.
| Modelid | Required | ID to assign to that model.
| Algo | Required | Algorithm used to build the model (currently lda is supported).
| Delta | Optional | Minimum delta to decide whether one model is better than another.
|numIterations | Optional | Specify the number of iterations used to refine the best model.
|============================================================================================

[[http-responses-21]]
==== HTTP Responses

[width="100%",cols="<25%,<25%,<50%",options="header",]
|==============================================================================================================================================================
|HTTP Status Code |HTTP Status Message |Description
|202 |ACCEPTED |Success. Includes an HTTP Location header specifying the location of the job ID that was created to handle the request.
`{"statusCode":"ACCEPTED","statusString":"Job Created","values":{}}`
|500 |INTERNAL SERVER ERROR |If the server refuses to accept the new job, it notifies the client with the error "Optimize Job execution was refused by server."
|==============================================================================================================================================================

[[http-response-entity-21]]
==== HTTP Response Entity
None

[[sample-requestresponse-16]]
==== Sample Request/Response
....
Request:
POST url="http://charm:8080/symetry/rest/c1/projects/irisTest/reduce?modelid=ldaOptimized&algo=lda&heuristic=default&delta=0.001&numIterations=5"

Body:
{"targets":["13"],"inputAttributes":["0","1","2","3","4","5","6","7","8","9","10","11","12","14"]}

Response Header:
Location: http://charm:8080/symetry/rest/c1/jobs/7

Response:
{"statusCode":"ACCEPTED","statusString":"Reduce Job Created","values":{}}

Job Request:
GET url="http://charm:8080/symetry/rest/c1/jobs/7

Job Response:
{"statusCode":"OK","statusString":"Job is finished","values":{}}
....

[[building-sequence-models]]
=== Building Sequence Models

Markov Chain Models and Hidden Markov Models are built differently. First, the project must be marked as a “sequence” project. After some data is learned, you can build Markov Chains, Hidden Markov Models, or both. These types of models have input attributes only; they do not have a target.

For Markov Chains, you input attributes to specify the sequence attributes to use. For Hidden Markov Model, you also specify the hidden state that must be categorical. The Observed state can be continuous or categorical. If it's continuous normal distribution will be assumed, mean and standard deviation of the data is used.

[[model-information]]
=== Model Information

This API function retrieves specific information about a model. A ModelInfo JSON data structure is returned (see the section "ModelInfo"). The response contains the type of model, attributes, and targets used by the model, along with specific information based on the type of model (info field).

[[url-22]]
==== URL
....
GET /symetry/rest/{cid}/projects/{pid}/models/{modelid}
....
[[http-responses-22]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|==================================================

[[http-response-entity-22]]
==== HTTP Response Entity

For information about ModelInfo JSON data structure see the section <<modelinfo-json>>.

[width="80%",cols="<40%,60%",options="header",]
|============================================
|HTTP Response Entity +
(see <<modelinfo-json>>)|
|ModelInfo |Contains information about model.
|============================================

[[sample-requestresponse-17]]
==== Sample Request/Response
....
Request:
GET url="http://charm:8080/symetry/rest/c1/projects/irisTest/models/ldaOptimized"

Response:
{"statusCode":"OK","statusString":"OK","values":{"modelInfo":{"modelType":"lda","attributeNames":["petal_length","petal_width","sepal_width","petal_length_b1","sepal_lengt_b1","sepal_width_b1","petal_width_b2","sepal_length"],"attributeIndexes":[2,3,1,6,4,5,7,0],"info":{"buildStatus":"\"No Error\"","z0":"18.9666","z1LTz0":"false","z":"\"l0 \u003c- c(3.93801 ,2.43275 ,-8.92229 ,-15.9048 ,0.997005 ,-1.15579 ,-4.66130 ,59.3254 )\n\"","buildTimeNanosec":"6553273","OverallContribution":"4.49040"},"predictInfo":["resZ","res","normZ"],"scoreInfo":["normZ"],"buildTime":54,"modelBuilt":140,"targetNames":["Iris_versicolor"],"targetindexes":[13],"modelId":"ldaOptimized"}}}
....

[[model-info-map-key]]
==== Model Info Map Key

The following table enumerates the additional specific keys/value pairs that are returned when asking for model information based on the type of model.

.Key/Value Pairs Returned When Asking for Model Information

[width="100%",cols="<25%,<75%",options="header",]
|=====================================================================================================================================================================================================
| Model Type | Model Keys
|*LDA* & *MLDA* |model +
distance +
z0 +
z +
Overall contribution for each input parameters
|*MLR* | model Betas
|*Ridge* | model Betas
|*QDA* |Model
|*LSVM* |svmNu +
svmGamma +
svmOmegas
|*LSVR* |svmNu +
svmGamma +
svmOmegas +
|*Bayes* |
|*Markov Chains* |Transition Matrix formatted as follows: +
{tm1$STATE:$:to$STATE – where STATE corresponds for Markov process state.
|*Hidden Markov Model* |Transition Matrix formatted as follows: +
{HIDDEN_tm1$STATE:$:HIDDEN_tm0$STATE – where HIDDEN/STATE corresponds for Markov process state group and state respectively. +
Emission Matrix formatted as follows +
 [HIDDEN_t0$STATE:$:OBSERVED$STATE – where HIDDEN/STATE corresponds for Markov process state-group and state respectively, while OBSERVED/STATE corresponds to the observed state-group and state.
|=====================================================================================================================================================================================================

[[get-code-for-model]]
=== Get Code for Model

LDA and MLR models allow retrieval of their internal representation as a Java method or SQL function. This API function call can be used with these models to perform predictions. The result is a string that represents the definition of a JAVA method or SQL function.

[[url-23]]
==== URL
....
GET /symetry/rest/{cid}/projects/{pid}/models/{modelid}/code?language=java
....

[[query-parameters-10]]
==== Query Parameters

[width="100%",cols="<25%,<25%,<50%",options="header",]
|========================================================================
|Parameter |Required/Optional? |Description
|language |Required |Targeted programming language for code. Choices are: +
- java = Java method. +
- sql = SQL function.
|========================================================================

[[http-responses-23]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|==================================================

[[http-response-entity-23]]
==== HTTP Response Entity

[width="100%", cols="<25%,<75%",options="header",]
|=============================
|HTTP Response Entity |Example
|String | `/* Java Function */ + 
public double ldaRed_score( + 
	double petal_length, +
	double petal_width, +
	double sepal_width +
	{ +  
		(-8.78 * petal_length) + 
		+ (-15.84 * petal_width) +
		+ (2.626 * sepal_width) + 
	}`
|=============================

[[sample-requestresponse-18]]
==== Sample Request/Response
....
Request:
GET url=http://charm:8080/symetry/rest/c1/projects/irisTest/models/model1/code?language=java

Response:
"{"statusCode":"OK","statusString":"OK","values":{"string":"/* Java Function */\npublic double ldaRed_score(\n\tdouble petal_length,\n\tdouble petal_width,\n\tdouble sepal_width,\n\tdouble petal_length_b1,\n\tdouble sepal_width_b1,\n\tdouble petal_width_b2,\n\tdouble sepal_length)\n{\n\treturn (-8.780458794255027 * petal_length) + \n\t\t(-15.841653689691597 * petal_width) + \n\t\t(2.6264699508510816 * sepal_width) + \n\t\t(-4.283122721819282 * petal_length_b1) + \n\t\t(-1.0747512015680236 * sepal_width_b1) + \n\t\t(58.97284497145444 * petal_width_b2) + \n\t\t(3.4278968694343033 * sepal_length);\n}\n"}}"
....

[[symetryml-job-information]]
== SymetryML Job Information


[[specific-job-information]]
=== Specific Job Information

This API function reports specific job information.

[[url-24]]
==== URL
....
GET /symetry/rest/{cid}/jobs/{jobid}
....
[[http-responses-24]]
==== HTTP Responses

[width="100%",cols="<25%,<25%,<50%",options="header",]
|==============================================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Job has finished.
`{"statusCode":"OK","statusString":"Job is finished","values":{}}`
|202 |ACCEPTED |Job is still running.
`{"statusCode":"ACCEPTED","statusString":"Job still running","values":{}}`
|400 |BAD REQUEST |Invalid job ID.
`{"statusCode":"BAD_REQUEST","statusString":"No such job","values":{}}`
|==============================================================================

[[http-response-entity-24]]
==== HTTP Response Entity

[width="100%",cols="<25%,<75%",options="header",]
|=================================================================================================================================================================
|HTTP Response Entity |Description +
The entity returned by the job depends on the type of job that just finished. For example:
|  ProjectInfo Jobs  | See <<symetryml-project-information-about-one-project>>. It returns a ProjectInfoList response (<<projectinfolist-json>>) upon completion.
| DS Predict Jobs | See <<prediction-api>>. Itreturns a DataFrame (<<dataframe-json>>) that contains the predictions.
| SVDJob | returns a KSVSMap (see <<ksvsmap-json>>).
|  PCA Job | return 2 entities (pcaVectors and pcaValues) Both are DataFrame data structure. (see <<dataframe-json>>) for details on DataFrame.
| AwsInfoJob | return a <<awsinfo-json>> datastructure
| DSUpdateJob | return <<projectinfo-json>> that reflect new state of the project.
| SparkDSUpdateJob | return <<projectinfo-json>> that reflect new state of the project.
|  Other jobs do not return any entity. |  
|If a job is not finished or has yet to be started, it returns a JobInfo entity that contains detailed information about a given job. See <<jobinfo-json>>.
|=================================================================================================================================================================

[[list-all-jobs]]
=== List All Jobs

This API function lists all current jobs.

[[url-25]]
==== URL
....
GET /symetry/rest/{cid}/jobs
....
[[http-responses-25]]
==== HTTP Responses

[width="100%",cols="<25%,<25%,<50%",options="header",]
|======================================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Job has finished.
`{"statusCode":"OK","statusString":"Job is finished","values":{}}`
|======================================================================

[[http-response-entity-25]]
==== HTTP Response Entity

[width="100%",cols="<25%,<75%",options="header",]
|=================================================================================
|HTTP Response Entity |Description
|JobInfo[] +
(see <<jobinfo-json>>) |Response contains a list of all the currently created on the computer.
|=================================================================================

[[kill-a-job]]
=== Kill a Job

This API function kills a job.

[[url-26]]
==== URL
....
DELETE /symetry/rest/{cid}/jobs/{jobid}
....
[[http-responses-26]]
==== HTTP Responses

[width="100%",cols="<25%,<25%,<50%",options="header",]
|===========================================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Job was killed.
|202 |ACCEPTED |Job cannot be killed.
|400 |BAD REQUEST |Invalid job ID.
`{"statusCode":"BAD_REQUEST","statusString":"No such job","values":{}}`
|===========================================================================

[[prediction-api]]
== Prediction API

[[url-27]]
=== URL
....
POST /symetry/rest/{cid}/projects/{pid}/predict/{modelid} [body=DataFrame]
....
[[http-responses-27]]
=== HTTP Responses

[width="100%",cols="<25%,<25%,<50%",options="header",]
|==========================================================================================================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|400 |BAD REQUEST |Invalid RTM ID.
`{"statusCode":"BAD_REQUEST","statusString":"Cannot Find SYMETRYML id[r2] for Customer id [c1]","values":{}}`
|500 |INTERNAL SERVER ERROR |Invalid model ID.
`{"statusCode":"INTERNAL_SERVER_ERROR","statusString":"Generic Exception \u003cError no such model \u003cm3\u003e\u003e","values":{}}`
|==========================================================================================================================================

[[http-response-entity-26]]
=== HTTP Response Entity

[width="100%",cols="<25%,<75%",options="header",]
|==================================================
|HTTP Response Entity |Example
|KSVSMap +
(see <<ksvsmap-json>>) |Contain information about the prediction.
|==================================================

[[sample-request-response]]
=== Sample Request Response
....
Request:
POST url="http://charm:8080/symetry/rest/c1/projects/irisTest/predict/testLDA"

Body:
{"attributeNames":["petal_length","sepal_width"],"data":[["1.5","5"]],"attributeTypes":["C","C"]}

Response:
{"statusCode":"OK","statusString":"OK","values":{"KSVSMap":{"values":[{"res":"1","normZ":"0.40997859439073814","resZ":"-2.4426003268943006","z0":"-3.840891864408894","z1LTz0":"false"}]}}}
....

[[model-prediction-map-keys]]
=== Model Prediction Map Keys

The prediction service returns a <<ksvsmap-json>>. This map is an array of map<key, value>, with key and value being strings. This is different from KSVDMap, where the values are double. The following table lists the model types and their corresponding KSVDMap key. The following table enumerates the keys returned by each model.

.Model Types and KSVDMap Keys
[width="100%",cols="<25%,<75%",options="header",]
|==================================================================================================================================================================================
|Model Type |KSVSMap Key
|*LDA* & *MLDA* |- *res*, 1 or 0 +
- *resZ* +
- *z0* +
- *z1GTz0* +
Examples: +
*Res :1 +
resZ :-1.66850 +
z0 :0.240482 +
z1GTz0 :true*
|*LSVM* |- *res*, 1 or 0
|*LSVR* |- *res*, the regression result
|*MLR* |- *res*, the regression result
|*QDA* |For each target in the model, a key,value pair is returned. The format of the key is ‘<**_attribute name>_**’. The value is the number computed by the model for that target. +
Example: +
*Corn :12.0509 * +
*Sugarbeets :11.4417 * +
*Clover :11.7757 * +
*Soybeans :12.0040* +
*Cotton :12.0634* +
The best scoring target is also returned in the ‘res’ key.
|*Bayes* |*res* = 0 or 1. +
*Prob* = contains the likelihood of the result.
|*Markov Chains* |*next* = contains the next state +
*next.p* = contains probability of the next state +
*seq.like* = contains the likelihood of the input sequence
|*Hidden Markov Model* |seq = sequence of hidden states 
|==================================================================================================================================================================================

[[data-source-api]]
== Data Source API


[[using-a-data-source]]
=== Using a Data Source

In SymetryML, a data source is an abstraction of a CSV file that resides somewhere and that can be used by:

* SymetryML projects to learn new data
* Models to make predictions and assessments
* Encoder to update their internal encoding table

SymetryML supports various types of data sources:

* Secure File Transfer Protocol (SFTP)
* HTTP/HTTPS URL
* Amazon Simple Storage Service (S3)
* Amazon RedShift
* S3 files processed by Spark Cluster (Spark S3)
* SymetryML data source plugins
* JDBC

To use a data source, create a JSON data structure described in <<dsinfo-json>> that contains the fields in <<dsinfo-fields-table>> table.

.Fields Required to Create a DSInfo Data Structure
[[dsinfo-fields-table]]
[width="100%",cols="<25%,<75%",options="header",]
|=====================================================================================================================================================================================
|Field |Description
|*type* |*Type of Data Source* +
- Secure FTP (SFTP) data source = sftp. +
- HTTP/HTTPS data source = http. +
- Amazon S3 = s3. +
- Amazon Redshift = rs. +
- Spark S3 Data Source = sparks3. +
- Data Source Plug ins. +
- jdbc +
|*name* |Name of the data source.
|*path* |*Path to the File* +
- Secure FTP (SFTP) data source = path to the file on the server. +
- HTTP/HTTPS data source = http:// or https:// URL. +
- Amazon S3 = path to file on the server, excluding the Amazon S3 bucket. +
- Amazon Redshift = name of the table to use. +
|*info* |*Hash Map Containing Additional Information Based on Data Source Type*  +
*Secure FTP (SFTP)* data source requires the following info: +
- info.sftpuser = user name used to connect to the SFTP server. +
- info.sftppasswd = user password used to connect to the SFTP server. +
- info.sftphost = host to which you want to connect. +
*Amazon S3* data source requires the following info: +
- info.s3accessKey = Amazon S3 access key to use to connect to S3. +
- info.s3secretKey = Amazon S3 secret key to use to connect to S3. +
- info.s3bucket = Amazon S3 bucket to use. +
*Amazon Redshift* data source requires the following info: +
- info.rsuser = Redshift database user +
- info.rspasswd = Redshift user password +
- info.rsurl = Redshift connection url +
*Spark S3 Map Reduce:* +
- sparkmaster = address of the spark’s cluster master. +
- *spark.job.process.jvm.heap.size.min* : Mininum JVM size used for the spark Driver process launched by the Jetty Rest Server. Default : 1024m +
- *spark.job.process.jvm.heap.size.max* : Maximum JVM size used for the spark Driver process launched by the Jetty Rest Server. Default: 2048m +
- Any Spark parameters be used also like + `spark.executor.memory` or `spark.executor.cores`. To pass such parameters, prefix them with ‘sml.sparkenv.’ as in the following examples: +
- `sml.sparkenv.spark.executor.cores` +
- `sml.sparkenv.spark.cores.max` +
*JDBC:* +
- driver +
- host +
- port +
- database +
- user +
- password
|=====================================================================================================================================================================================


[[additional-csv-options]]
==== Additional CSV Options

You can specify additional parameters that describe the ‘type of csv files’. You can also add the following parameters to a data source to change how SymetryML parses your data:

[width="100%", cols="<25%,<75%",options="header",]
|===============================================================================================================================================================
|Key |Description
|*csv_entry_separator* |Specifies which character to use as the delimiter for each record for a given tuple.
|*csv_quote_character* |Specifies the quote character.
|*csv_strict_quotes* |Setting this option to true discards characters outside the quotes. If there are no quotes between delimiters, an empty string is generated.
|*csv_header_missing* |Specifies that this data source does not have any header. SymetryML can then generate a header automatically.
|===============================================================================================================================================================

[[additional-information-on-spark-s3-data-source]]
==== Additional Information on Spark S3 Data Source

SymetryML can leverage a spark cluster to speed up processing of large amounts of data significantly. Currently, your data must reside on Amazon S3. Depending on the size of your data, it may take more or less time for the job to start, as the Spark Cluster must compute the partitions of your data before starting the job. Consequently, if your data is very large, this may take a few minutes.

Please be sure to consult the <<../../guides/SML_Installation_Guide_Spark.adoc#, Spark Installation Guide>> for additional Spark information - and more particularly the <<../../guides/SML_Installation_Guide_Spark.adoc#additional-symetryml-configuration-for-spark-support, Additional SymetryML Configuration for Spark Support>> section.

*Best practices for Spark S3 Data Source:*

* Performance may vary depending on Amazon resource utilization when you run your job.
* Be sure all executor nodes in your cluster reside in the same Amazon ec2 placement group.


[[about-data-source-plugins-dsplugins]]
==== About Data Source Plugins (DSPlugins)

The SymetryML data source API allows you to create a new data source by the form of Java library (jar) that can be added the server. Instead of transforming data into csv files, for example, you can write a DS plugin that reads the data natively.



[[data-source-encryption]]
=== Data Source Encryption

Data sources might contain sensitive information that should never be passed in the clear. To avoid having to use HTTPS for these services, the SymetryML REST API forces you to pass such information in encrypted form. This can be done easily, as each SymetryML secret key is also a 128-bit Advanced Encryption Standard (AES) secret key.

1.  Create your DSInfo data structure (see the section <<dsinfo-json>>) and enter the appropriate information so that the SymetryML server can access it.
2.  Extract the JSON string from that data structure.
3.  Encrypt the JSON string representation using your SymetryML secret key:

* Initialization vector in Base 64: *LzM5QUtXZXWHm7HJ4wAePg==*
* Block cipher algorithm: *AES/CBC/PKCS5Padding*

4.  Send the encrypted string as part of the body to any REST service that requests a DSInfo as the body.
5.  The server decrypts the string using the client secret key and reconstructs the DSInfo.

See <<appendixb>> - for code example on how to perform this encryption in Java, JavaScript, or Python.

[[data-source-create]]
=== Data Source Create

This API function creates a new data source.

[[url-28]]
==== URL
....
POST /symetry/rest/{cid}/dss/create [Body=DSInfo (encrypted)]
....
[[http-responses-28]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|====================================================================
|HTTP Status Code |HTTP Status Message |Description
|202 |CREATED |Success.
|409 |CONFLICT |A data source with the specified name already exists.
|====================================================================

[[http-response-entity-27]]
==== HTTP Response Entity

None.

[[sample-requestresponse-19]]
==== Sample Request/Response
Please note that in the following example the BODY is encrypted. Refer to section <<data-source-encryption>> for encryption details.
....
Request:
POST url="http://charm:8080/symetry/rest/c1/dss/create"

Body:
emUmJ7LXKaICPww/dKRoMR/Go6+B3ATTn+GwgE1/vcK9pN/mLoqGyKiMtGiTYMct4Gth1ElniKLXtmXfHfs7Rfn+QhJHZ+s00w2PBdbvYZIoF3My04H5XCboY21Fh4SkBhsxo+DhYuardN7R+uGphN/DSbiHRLIXe51HijSpfuq0fJuQYW0ccN4FM/B74LJccuDnbb+IouS9u/9rybKu/wsVbDVRTK/zZpWXyn4qtds=

Response:
{"statusCode":"CREATED","statusString":"DS created with name [ds1] for customer [c1]","values":{}}
....

[[data-source-update]]
=== Data Source Update

This API function update an existing data source.

[[url-29]]
==== URL
....
PUT /symetry/rest/{cid}/dss/{dsname} [Body=DSInfo (encrypted)]
....
[[http-responses-29]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|======================================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|404 |NOT FOUND |If data source with the specified name does not exist.
|======================================================================

[[http-response-entity-28]]
==== HTTP Response Entity

None.

[[sample-requestresponse-20]]
==== Sample Request/Response
Please note that in the following example the BODY is encrypted. Refer to section <<data-source-encryption>> for encryption details.

....
Request:
PUT url="http://charm:8080/symetry/rest/c1/dss/aDataSourceName"

Body:
emUmJ7LXKaICPww/dKRoMR/Go6+B3ATTn+GwgE1/vcK9pN/mLoqGyKiMtGiTYMct4Gth1ElniKLXtmXfHfs7Rfn+QhJHZ+s00w2PBdbvYZIoF3My04H5XCboY21Fh4SkBhsxo+DhYuardN7R+uGphN/DSbiHRLIXe51HijSpfuq0fJuQYW0ccN4FM/B74LJccuDnbb+IouS9u/9rybKu/wsVbDVRTK/zZpWXyn4qtds=

Response:
{"statusCode":"OK","statusString":"DS updated with name [ds1] for customer [c1]","values":{}}
....

[[list-customer-data-sources]]
=== List Customer Data Sources

This API function returns all the data sources that belong to a user.

[[url-30]]
==== URL
....
GET /symetry/rest/{cid}/dss/
....
[[http-responses-30]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|==================================================

[[http-response-entity-29]]
==== HTTP Response Entity

[width="100%",cols="<25%,<75%",options="header",]
|==============================================================================================================================================================================================================================
|HTTP Response Entity |Example
|StringList +
see <<stringlist-json>>|`{"statusCode":"OK","statusString":"OK","values":{"stringList":{"values":["Iris_SymetryML.csv-predict.csv:s3","h1:http","BigData11g_Test.csv:http","Iris_SymetryML.csv:s3","Smaato_Bids_20130812_CTR.csv:s3"]}}}`
|==============================================================================================================================================================================================================================

[[sample-requestresponse-21]]
==== Sample Request/Response
....
Request:
GET url="http://charm:8080/symetry/rest/c1/dss"

Response:=
{"statusCode":"OK","statusString":"OK","values":{"stringList":{"values":["Iris_rtlm-out-neil.csv:s3","Iris_rtlm.csv:s3","BigData11g_num.csv:s3","Smaato_Bids_20130812_CTR.csv:s3"]}}}
....

[[delete-data-source]]
=== Delete Data Source

This API function deletes a data source.

[[url-31]]
==== URL
....
DELETE /symetry/rest/{cid}/dss/{dsname}
....
[[http-responses-31]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|=============================================================================================================================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|409 |CONFLICT |Data source cannot be deleted. A SymetryML project might be using the data source. The response contains an error string with further details.
|=============================================================================================================================================================

[[http-response-entity-30]]
==== HTTP Response Entity

None

[[data-source-information]]
=== Data Source Information

This API function returns information about a data source. Because this information can be sensitive, the server encrypts it to ensure that the information will be returned safely, even when using HTTP. Use your SymetryML secret key to decrypt the information. For information about how to decrypt the response, see the section <<data-source-encryption>>.

[[url-32]]
==== URL
....
GET /symetry/rest/{cid}/dss/{dsname}
....
[[http-responses-32]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|==================================================

[[http-response-entity-31]]
==== HTTP Response Entity

[width="100%",cols="<25%,<75%",options="header",]
|===================================================================
|HTTP Response Entity |Example
|DSInfo (encrypted) |DSInfo encrypted using the customer secret key. (see <<dsinfo-json>>)
|===================================================================

[[sample-requestresponse-22]]
==== Sample Request/Response
....
Request:
GET url="http://charm:8080/symetry/rest/c1/dss/BigData11g_num.csv"

Response:
{"statusCode":"OK","statusString":"OK","values":{"dsinfo":"emUmJ7LXKaICPww/dKRoMRNJEMepL37Eq9CgZfhZPWj93mo3A+C8ucfIOGaPwwn2dip/JEuLFjUT/fjHjy18XKFnzFz5Ujp0WmS0uA4ssvAJwNPL6BvnsY6+a/lKa+c/q9/5tz5lr13N13I7OGAhuYhXYV+xb8oFZqsn+bH5spBXRb5u+oyEMXNKLCaNt3pzc/xCyW47KCwIi9V5iSA+fcJAWfetm9ZsIHNbI6utkxKrqrU5OfLmgriGAP++yQtutlGR7r/bKV1bRc8UDsgsXQg1HgoxHcKXCgsAFDFzqsJmZ/5/uQDc0ytc5Fk85GUx"}}
....

[[data-source-browsing]]
=== Data Source Browsing

This API function lists content about a remote data source directory.

[[url-33]]
==== URL
....
POST /symetry/rest/{cid}/projects/dsbrowse/ [Body=DSListingRequest (encrypted)]
....
[[http-responses-33]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|==================================================

[[http-response-entity-32]]
==== HTTP Response Entity

[width="100%", cols="<25%,<75%",options="header",]
|=============================================================================================================================================================================================
|HTTP Response Entity |Description
|<<dslistingresponse-json>> |Contains listing information about the requested directory or folder.
|=============================================================================================================================================================================================

[[sample-requestresponse-23]]
==== Sample Request/Response
....
Request:
POST url="http://charm:8080/symetry/rest/c1/projects/dsbrowse"

Body:
drhSjndw6G15pgevCsDqaSfjX9x3hMo+dNqd/MV943Dsd2rl2guhvq2qUhjEORcfKAEjHaoRZMKmSbQB6bcca2YT6HmUyRxuOG0wiKgGy0MOEq7+iIncbX4orpGr4rhro1Frw909Uy8qcWskaInQHJT4EGRPcwxvwInFlea39hsMkycFK4pKlTpanOUYgcv7

Response:
{"statusCode":"OK","statusString":"OK","values":{"dsdirectoryListing":{"ok":true,"dirs":["data2/","folder-a/","folder-datasets/","folder-demo/","folder-dev/","folder-dev-pub-http/","folder-dev-pub-https/","folder-docs/","folder-perf-all-reports/","folder-source/"]}}}
....

[[fetching-sample-data-1]]
=== Fetching Sample Data 1

This API function fetches a data source sample by specifying the data source information as part of the request body. The response returns up to 128 lines. This REST call needs a request body that contains an encrypted DSInfo data structure (see the section <<data-source-encryption>>).

[[url-34]]
==== URL
....
POST /symetry/rest/{cid}/dss/sample/preview [body=DSInfo encrypted]
....
[[http-responses-34]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|==================================================

[[http-response-entity-33]]
==== HTTP Response Entity

[width="100%",cols="<25%,<75%",options="header",]
|==================================================================================================
|HTTP Response Entity |Description
|DataFrame |Contains a sample of the data source up to 128 lines. (see <<dataframe-json>>)
|==================================================================================================

[[sample-requestresponse-24]]
==== Sample Request/Response
....
Request:
POST url="http://charm:8080/symetry/rest/c1/dss/sample/preview

Body:
WTqUHBoXHbl+cMMjdc0zgjBP8e44G1os15V+I4GZgDOr1dX9uOfvY5uK9ZgC9yral9XC1ohD1W+UvkPlKR4dQT00EgCdS2UPgZz2NwwooHOM+KY1Ysf5qZlkFKiOkxwoWH/mr3mvvgdTUpZS8zrDJk3gwsavFT5fe0J2lTR33F1OH7FwxP4qs5nzRbVz546l

Response:
{"statusCode":"OK","statusString":"OK","values":{"dataframe":{"attributeNames":["adexchange","imp_width","imp_height","imp_btype","preference","pub","domain","site_base_url","category","device_ip","device_country","device_dma","device_state","device_city","zip","device_carrier","language","device_os","device_make","device_model","device_osv","lat","lon","restriction_bcat","restriction_badv","position","gender","user_keyword","user_yob","user_age","view_count","campaign","creative","creative_type","winner","bid_price","win_price","clicked","rtlm_ctr_score","rtdm","req_hour","req_day","category_count","bcat_count","badv_count"],"data":[["Smaato","320","50","","APP","New IT Solutions Ltd","","","Technology \u0026 Computing","157.55.32.83","US","","WASHINGTON","REDMOND","98052","","","Unknown","","","","47.67398834","-122.1215134","IAB7-28|IAB19-30|IAB22-1|IAB19-3|IAB17-18|IAB26|IAB25|IAB24|IAB9-9|IAB7-

(...)

,"attributeTypes":["S","C","C","L","S","L","S","S","S","S","S","S","S","S","S","S","S","S","S","S","S","S","S","L","S","S","S","S","S","S","B","S","S","S","B","C","C","B","S","B","C","C","B","C","B"]}}}
....

[[fetching-sample-data-2]]
=== Fetching Sample Data 2

This API function fetches a previously created data source sample. Use the {dsname} parameter to specify which data source to retrieve the preview.

[[url-35]]
==== URL
....
GET /symetry/rest/{cid}/dss/{dsname}/sample
....
[[http-responses-35]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|==================================================

[[http-response-entity-34]]
==== HTTP Response Entity

[width="100%",cols="<40%,<60%",options="header",]
|============================================
|HTTP Response Entity |Description
|DataFrame |See <<dataframe-json>>.
|============================================

[[sample-requestresponse-25]]
==== Sample Request/Response
....
Request:
GET url="http://charm:8080/symetry/rest/c1/dss/Smaato_Bids_20130812_CTR.csv/sample"

Response:
{"statusCode":"OK","statusString":"OK","values":{"dataframe":{"attributeNames":["adexchange","imp_width","imp_height","imp_btype","preference","pub","domain","site_base_url","category","device_ip","device_country","device_dma","device_state","device_city","zip","device_carrier","language","device_os","device_make","device_model","device_osv","lat","lon","restriction_bcat","restriction_badv","position","gender","user_keyword","user_yob","user_age","view_count","campaign","creative","creative_type","winner","bid_price","win_price","clicked","rtlm_ctr_score","rtdm","req_hour","req_day","category_count","bcat_count","badv_count"],"data":[["Smaato","320","50","","APP","New IT Solutions Ltd","","","Technology \u0026 Computing","157.55.32.83","US","","WASHINGTON","REDMOND","98052","","","Unknown","","","","47.67398834","-122.1215134","IAB7-28|IAB19-30|IAB22-1|IAB19-3|IAB17-18|IAB26|IAB25|IAB24|IAB9-9|IAB7-

(...)

,"attributeTypes":["S","C","C","L","S","L","S","S","S","S","S","S","S","S","S","S","S","S","S","S","S","S","S","L","S","S","S","S","S","S","B","S","S","S","B","C","C","B","S","B","C","C","B","C","B"]}}}
....

[[symetryml-project-data-source-api]]
=== SymetryML Project Data Source API

[[add-data-source-to-a-symetryml-project]]
==== Add Data Source to a SymetryML project

This API function lets you add a data source to a project.

[[url-36]]
===== URL
....
GET /symetry/rest/{cid}/projects/{pid}/addds/{dsname}
....
[[http-responses-36]]
===== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|==================================================

[[http-response-entity-35]]
===== HTTP Response Entity

None

[[remove-data-source-from-a-symetryml-project]]
==== Remove Data Source from a SymetryML project

This API function lets you remove a data source from a project.

[[url-37]]
===== URL
....
GET /symetry/rest/{cid}/projects/{pid}/detachds/{dsname}
....
[[http-responses-37]]
===== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|==================================================

[[http-response-entity-36]]
===== HTTP Response Entity

None

[[learning-data-from-a-data-source]]
==== Learning Data from a Data Source

This API function lets you learn from a previously created data source.

[[url-38]]
===== URL
....
GET /symetry/rest/{cid}/projects/{pid}/dss/{dsname}/learn
....

[[http-responses-38]]
===== HTTP Responses

[width="100%",cols="<25%,<25%,<50%",options="header",]
|================================================================================================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success. Includes an HTTP Location header specifying the location of the job ID that was created to handle the request. +
Example: +
`{"statusCode":"ACCEPTED","statusString":"Job Created","values":{}}`
|================================================================================================================================

[[http-response-entity-37]]
===== HTTP Response Entity

None

[[sample-requestresponse-26]]
===== Sample Request/Response
....
Request 1 create ds:
POST url=http://charm:8080/symetry/rest/c1/dss/create

Body 1:
{ENCRYPTED}

Request 2 learn ds:
POST url=http://charm:8080/symetry/rest/c1/projects/r1/dss/irisds/learn

BODY 2
{"errorHandling":1,"attributeNames":["sepal_length","sepal_width","petal_length","petal_width","sepal_lengt_b1","sepal_lengt_b2","sepal_width_b1","sepal_width_b2","petal_length_b1","petal_length_b2","petal_width_b1","petal_width_b2","Iris_setosa","Iris_versicolor","Iris_virginica"],"data":[],"attributeTypes":["C","C","C","C","B","B","B","B","B","B","B","B","B","B","B"]}

Response 2:
{"statusCode":"ACCEPTED","statusString":"Job Created","values":{}}

Response 2 Header:
Location: http://charm:8080/symetry/rest/c1/jobs/4

Job 3 Request:
GET url="http://charm:8080/symetry/rest/c1/jobs/4

Job 3 Response:
{"statusCode":"OK","statusString":"Job is finished","values":{"smlInfo":{"pid":"r1","isDirty":true,"modelsList":[],"modelTypeList":[],"attributeNames":["sepal_length","sepal_width","petal_length","petal_width","sepal_lengt_b1","sepal_lengt_b2","sepal_width_b1","sepal_width_b2","petal_length_b1","petal_length_b2","petal_width_b1","petal_width_b2","Iris_setosa","Iris_versicolor","Iris_virginica"],"attributeIndexes":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14],"attributeTypes":["C","C","C","C","B","B","B","B","B","B","B","B","B","B","B"],"modelAssessments":{},"modelPredictions":{},"hash":-1,"categorySeparator":"$","type":"cpu","creationDate":1488220762857,"lastModificationDate":1488226030143,"loaded":true,"persisted":true}}}

....

[[forgetting-data-from-a-data-source]]
==== Forgetting Data from a Data Source

This API function lets you forget data from a previously created data source.

[[url-39]]
===== URL
....
GET /symetry/rest/{cid}/projects/{pid}/dss/{dsname}/forget
....
[[http-responses-39]]
===== HTTP Responses

[width="100%",cols="<25%,<25%,<50%",options="header",]
|=============================================================================================================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success. Includes an HTTP Location header specifying the location of the job ID that was created to handle the request. For example:
`{"statusCode":"ACCEPTED","statusString":"Job Created","values":{}}`
|=============================================================================================================================================

[[http-response-entity-38]]
===== HTTP Response Entity

None

[[sample-requestresponse-27]]
===== Sample Request/Response

See the section previous <<sample-requestresponse-26>> and replace `learn` with `forget` in the url.

[[prediction-based-on-a-data-source]]
==== Prediction Based on a Data Source

After a model is built, you can use this API function to make predictions using a data source. This action can be performed on very large files if they reside on Amazon S3. A prediction file is created that contains the original rows, along with additional prediction information based on the type of model used.

[[url-40]]
===== URL
....
GET /symetry/rest/{cid}/projects/{pid}/dss/predict/{modelid}?indsname={indsname}&outdsname={outdsname}
....
[[query-parameters-11]]
===== Query Parameters

[width="100%", cols="<25%,<25%,<50%",options="header",]
|======================================================================
|Parameter |Required/Optional? |Description
|indsname |Required |Data source to use as input file for prediction.
|outdsname |Required |Data source to use as output file for prediction.
|======================================================================

[[http-responses-40]]
===== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|=====================================================================================================================================================
|HTTP Status Code |HTTP Status Message |Description
|202 |ACCEPTED |Success. Includes an HTTP Location header specifying the location of the job ID that was created to handle the request.
|500 |INTERNAL SERVER ERROR |If the server refuses to accept the new job, it notifies the client with the error "Job execution was refused by server."
|=====================================================================================================================================================

[[http-response-entity-39]]
===== HTTP Response Entity

None

[[sample-requestresponse-28]]
==== Sample Request/Response
....
Request:
GET url="http://charm:8080/symetry/rest/c1/projects/irisTest/dss/predict/testLDA?indsname=dsin&outdsname=dsout

Response Header:
Location: http://charm:8080/symetry/rest/c1/jobs/2

Response:
{"statusCode":"ACCEPTED","statusString":"Job Created","values":{}}

Job Request:
GET url="http://charm:8080/symetry/rest/c1/jobs/2

Job Response:
{"statusCode":"OK","statusString":"Job is finished","values":{"dataframe":{"attributeNames":["resZ_Result","res_Result","normZ_Result","sepal_length","sepal_width","petal_length","petal_width","sepal_lengt_b1","sepal_lengt_b2","sepal_width_b1","sepal_width_b2","petal_length_b1","petal_length_b2","petal_width_b1","petal_width_b2","Iris_setosa","Iris_versicolor","Iris_virginica"],"data":[["-0.4559922893809558","1","0.2929126883636288","4.3","3","1.1","0.1","1","0","0","1","1","0","1","0","1","0","0"],["-0.5225734165408404","1","0.2965158290613048","

(…)

["-2.6526076600477295","1","0.4232667751179995","6.9","3.1","5.4","2.1","0","1","0","1","0","1","0","1","0","0","1"]]}}}
....

[[encoder-data-source-api]]
=== Encoder Data Source API


[[updating-an-encoder-with-a-data-source]]
==== Updating an Encoder with a Data Source

This API function updates an Encoder with data from a data source.

[[url-41]]
===== URL
....
GET /symetry/rest/{cid}/encoders/{encodername}/learnds [body = DSInfo (encrypted)]
....
[[http-responses-41]]
===== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|=====================================================================================================================================================
|HTTP Status Code |HTTP Status Message |Description
|202 |ACCEPTED |Success. Includes an HTTP Location header specifying the location of the job ID that was created to handle the request.
|500 |INTERNAL SERVER ERROR |If the server refuses to accept the new job, it notifies the client with the error "Job execution was refused by server."
|=====================================================================================================================================================

[[http-response-entity-40]]
===== HTTP Response Entity

None

[[sample-requestresponse-29]]
==== Sample Request/Response
....
Request:
POST url="http://charm:8080/symetry/rest/c1/encoders/enctest/learnds

Request Body:
emUmJ7LXKaICPww/dKRoMZo4y++JZksKFU3xx80mZ0E83ED6eCXhZ7PR1jzizIQg/uH19jVkSUWnDxul9+NIqZe7a9Yz5a8gW1kpRHJ7SyOYoo7oV90atrkMcZ73Jj0FRn53P81t8Q+7fCTwMYRfD52hjCbwtvdwFCbPbhPo1c9CAk9QLhtAFLDWVqblBeBXTPR8/0zfKJWtwj30Yr0gwqeTI3+BMOMEvH28WFWXo+wBdgkMBpXJsQH/zbPvVdCp9P+BJWp/E1Ju2hUzPO5c2k3/Dmqv3xWNmsQzEJWNMFTJnBG33hTUyTr/+j87NsM2e1luWvf1KaNzaatjS1ZZ9AQCp7gv48vMVrzEHs4ePiOFq5t0UElAu1kzFerhtNxEFmC9A90Gjt3FSLrEGgx5emZ0uogJa6m4nufbQnKUrUZL1sILmLfReZOqnPKp59HqjiiczpkPQ2vPfhmFpaM2RYaEHbqSpMGCnBO9Axij9ExPjR4X9aqHOzKw2yBba4Em

Response Header:
Location: http://charm:8080/symetry/rest/c1/jobs/4

Response:
{"statusCode":"ACCEPTED","statusString":"Job Created","values":{}}

Job Request:
GET url="http://charm:8080/symetry/rest/c1/jobs/4

Job Response:
{"statusCode":"OK","statusString":"Job is finished","values":{}}
....

[[listing-a-data-source-used-by-an-encoder]]
==== Listing a Data Source Used by an Encoder

This API function lists the data source(s) that were used to update an Encoder.

[[url-42]]
===== URL
....
GET /symetry/rest/{cid}/encoders/{encodername}/dss
....
[[http-responses-42]]
===== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|======================================================================================================================================
|HTTP Status Code |HTTP Status Message |Description
|202 |ACCEPTED |Success. Includes an HTTP Location header specifying the location of the job ID that was created to handle the request.
|======================================================================================================================================

[[http-response-entity-41]]
===== HTTP Response Entity

[width="100%",cols="<25%,<75%",options="header",]
|=============================
|HTTP Response Entity |Example
|StringList |See <<stringlist-json>>
|=============================

[[sample-requestresponse-30]]
===== Sample Request/Response
....
Request:
GET url="http://charm:8080/symetry/rest/c1/encoders/enctest/dss

Response:
{"statusCode":"OK","statusString":"OK","values":{"stringList":{"values":["s12"]}}}
....

[[data-source-job-status]]
=== Data Source Job Status

When invoking a JobStatus for a job that was initiated for learning, forgetting, or making predictions based on a data source, the response might contain an entity. The following sections describe these cases.

[[learning-a-data-source]]
==== Learning a Data Source

[[http-responses-43]]
===== HTTP Responses

[width="100%",cols="<25%,<25%,<50%",options="header",]
|========================================================================================================================================================================================================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |No entity.
|202 |ACCEPTED |Job is not finished. Includes a JobInfo entity. For more information, see the section <<jobinfo-json>> +
Using the current and maximum fields, you can compute the percentage of the job that was accomplished so far. "Maximum" refers to the size of the file to process and contains the approximate number of bytes processed by the job.
|========================================================================================================================================================================================================================================

[[forgetting-a-data-source]]
==== Forgetting a Data Source

[[http-responses-44]]
===== HTTP Responses

[width="100%",cols="<25%,<25%,<50%",options="header",]
|====================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |No entity.
|202 |ACCEPTED |Job is not finished. Includes a JobInfo entity. For more information, see the section <<jobinfo-json>> and also the section <<symetryml-job-information>>.
Using the current and maximum fields, you can compute the percentage of the job that was accomplished so far. "Maximum" refers to the size of the file to process and contains the approximate number of bytes processed by the job.
|====================

[[prediction-based-on-data-source]]
==== Prediction Based on Data Source

[[http-responses-45]]
==== HTTP Responses

[width="100%",cols="<25%,<25%,<50%",options="header",]
|====================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |DataFrame that contains a sample of the predictions (up to 128 lines). Because Amazon files can be very large, it is not possible to return the prediction result file in its entirety within a REST call. Use your favorite tool to fetch the prediction results from the data source (S3 or SFTP). +
The prediction result file contains all the original file columns, plus the additional prediction column for each row. Any additional columns depend on the type of model used to make the predictions.
|202 |ACCEPTED |Job is not finished. Includes a JobInfo entity. For more information, see the section <<jobinfo-json>> +
Using the current and maximum fields, it is possible to compute the percentage of the job that was accomplished so far. "Maximum" refers to the size of the file to process and contains the approximate number of bytes processed by the job.
|====================

[[stream-api]]
== Stream Data Source API

Data source described in the <<data-source-api>> section all are _finite_ type of data source int he sense that they all have a _finite_ number of rows. SymetryML also support 'Stream Data Source' that in theory can contain an infinite number of rows. For now only Kafka Stream Data Source can be created.

=== Kafka Streams 
To use a Kafka stream data source, create a JSON data structure described in <<dsinfo-json>> that contains the fields in <<kafka-dsinfo-fields-table>> table. Please note that for SymetryML to be able to read the data in your topic it needs to use both the `KafkaAvroDeserializer` as well as the Kafka Registry.

.Fields Required to Create a Stream DSInfo Data Structure
[[kafka-dsinfo-fields-table]]
[width="100%",cols="<25%,<75%",options="header",]
|=================
|Field | Description
|*type* |*Type of Data Source* +
- Only `kafka` for now +
|*name* | Name of the data source.
|*path* | TBD +
|*info* |*Hash Map* Containing Information needed to create a Kafka Stream. Please consult the next table <<kafka-dsinfo-kafka-parameters-table>> for details: 

|=================

.Kafka Parameters
=== Kafka Stream Additional Information
[[kafka-dsinfo-kafka-parameters-table]]
[width="100%",cols="<25%,<25%,<75%",options="header",]
|=================
|Key | Required ? | Description
|*bootstrap.servers* | Required | 
|*schema.registry.url* | Required | 
|*kafka.topic* | Required | 
|*kafka.partitions* | Optional | default to all partitions
|*kafka.stream.time_between_persist* | Optional | Default to 300 seconds, that is 5 minutes. How long to wait between when the Symetry Project will persist its state. To disable this pass -1.
|*enable.auto.commit* | Optional | default to true
|*auto.commit.interval.ms* | Optional | default to 1000 ms.
|*auto.offset.reset* | Optional | default to 'earliest'
|*Any other kafka parameter* | Optional | Any Kafka parameters can be used as well. One needs to prefix them with `sml.kafka.` + 
e.g. +
`sml.kafka.client.dns.lookup` or +
`sml.kafka.fetch.min.bytes`
|=================


[[stream-ds-encryption]]
=== Stream Data Source Encryption

Same as one need to encrypt normal data source, stream data source information needs to be encrypted. Please consult the <<data-source-encryption>> for details.


[[stream-ds-create]]
=== Stream Data Source Create

This API function creates a new stream data source and attach it to a SymetryML project - the owner project. Once created the new stream data source will continuously pull data from Kafka and then push the new data tuple into SymetryML Project in a streaming fashion.

[[stream-ds-create-url]]
==== URL
....
POST /{cid}/projects/{pid}/streams/create [Body=DSInfo (encrypted)]
....
[width="100%",cols="<25%,<25%,<50%",options="header",]
|=================
|Parameter |Required/Optional? |Description
|*fromBeginning* |Optional | if true then start streaming data from beginning of the stream.
|=================


[[stream-ds-create-response]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|====================================================================
|HTTP Status Code |HTTP Status Message |Description
|202 | CREATED | Success.
|409 | CONFLICT | A stream data source with the specified name already exists.
|====================================================================

[[stream-ds-browse]]
=== Stream Data Source Browse

This methods allows you to browse available stream on your stream server. For Kafka this means listing topic that are available.

[[stream-ds-browse-url]]
==== URL
....
POST /{cid}/streams/browse [Body=DSInfo (encrypted)]
....
[[stream-ds-browse-response]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|==================================================

[[stream-ds-browse-response-entity]]
==== HTTP Response Entity

[width="100%", cols="<25%,<75%",options="header",]
|===============
|HTTP Response Entity |Description
|<<dslistingresponse-json>> |Contains listing information from the streaming server.
|===============


[[stream-ds-preview]]
=== Stream Data Source Preview

This methods allows you to preview a sample of the data available on a given stream.

[[stream-ds-preview-url]]
==== URL
....
POST /{cid}/streams/preview [Body=DSInfo (encrypted)]
....
[[stream-ds-preview-response]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|==================================================

[[stream-ds-preview-entity]]
==== HTTP Response Entity

[width="100%", cols="<25%,<75%",options="header",]
|===============
|HTTP Response Entity |Description
|<<dataframe-json>> | Dataframe containing a preview of the data
|===============



[[stream-ds-metrics]]
=== Stream Data Source Metrics

This rest endpoint return information about a stream. Number of rows processed, tuples / secs processed, etc... Information varies with the type of the stream.

[[stream-ds-metrics-url]]
==== URL
....
GET /{cid}/projects/{pid}/streams/{sid}/metrics 
....
[[stream-ds-metrics-response]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|==================================================

[[stream-ds-metrics-entity]]
==== HTTP Response Entity

[width="100%", cols="<25%,<75%",options="header",]
|===============
|HTTP Response Entity |Description
|<<ksvsmap-json>> | A map with key, value as string pair
|===============



[[stream-ds-start]]
=== Stream Data Source Start

This rest endpoint start / resume a stream data source. That is start pulling data and push it into the owner SymetryML project.

[[stream-ds-start-url]]
==== URL
....
GET /{cid}/projects/{pid}/streams/{sid}/start 
....
[width="100%",cols="<25%,<25%,<50%",options="header",]
|=================
|Parameter |Required/Optional? |Description
|*fromBeginning* |Optional | if true then start streaming data from beginning of the stream.
|=================

[[stream-ds-start-response]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|==================================================


[[stream-ds-stop]]
=== Stream Data Source Stop

This rest endpoint stop a stream data source. Data will not be pushed anymore to the owner SymetryML project.

[[stream-ds-stop-url]]
==== URL
....
GET /{cid}/projects/{pid}/streams/{sid}/stop 
....

[[stream-ds-stop-response]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|==================================================



[[stream-ds-errorlog]]
=== Stream Data Source Error Log

This rest endpoint return a list of error for a given stream. Since stream happen asynchronously in the background, it allows to check for any problems with a given stream

[[stream-ds-errorlog-url]]
==== URL
....
GET /{cid}/projects/{pid}/streams/{sid}/errorLog
....
[[stream-ds-errorlog-response]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|==================================================

[[stream-ds-errorlog-entity]]
==== HTTP Response Entity

[width="100%", cols="<25%,<75%",options="header",]
|===============
|HTTP Response Entity |Description
|<<stringlist-json>> | A list of error for that stream
|===============



[[stream-ds-list]]
=== Stream Data Source List

This rest endpoint return a list of streams name that belong to a given project for a given user.

[[stream-ds-list-url]]
==== URL
....
GET /{cid}/projects/{pid}/streams/list
....
[[stream-ds-list-response]]
==== HTTP Responses

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|==================================================

[[stream-ds-list-entity]]
==== HTTP Response Entity

[width="100%", cols="<25%,<75%",options="header",]
|===============
|HTTP Response Entity |Description
|<<stringlist-json>> | A list of stream data source name
|===============


[[misc-api]]
== Miscellaneous API

[[histogram-enable]]
=== Enable Histogram

[[histogram-enable-url]]
==== URL
....
POST /{cid}/projects/{pid}/histogramEnable?enable=[true|false]
....

[[hist-query-parameters]]
==== Query Parameters

[width="100%", cols="<25%,<25%,<50%",options="header",]
|====================================
|Parameter |Required/Optional? |Description
| enable |Required | Whether to enable or disable histogram for this project.
| window |Optional | Number of sample to keep, default to 1,000,000.
|====================================


[[histogram-enable-response]]
==== HTTP Responses

[width="100%",cols="<25%,<25%,<50%",options="header",]
|=============================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|400 |BAD REQUEST |User does not have the SymetryML project. +
`{"statusCode":"BAD_REQUEST","statusString":" +
Customer[c1] does not have Project with id[r1], ","values":{}}`
|=============================


[[websocket-api]]
== WebSocket API



[[websocket-overview]]
=== WebSocket Overview

SymetryML supports the use of WebSocket technology on a subset of its API. This API can be used when lower latency is needed. Each WebSocket call contains a set of 3 pieces of information:

* The headers, which are used to authenticate the request.
* The message payload.
* The field delimiter.

The following table describes this information.

[width="100%",cols="<25%,<75%",options="header",]
|====================
|Field |Description
|Header |A JSON string containing 2 pieces of information +
- header[4] = an array of 4 string used for authorization. +
- date +
- md5 +
- authorization hash code. +
- customer id +
- extraKeys = contains extra information that depends on the WebSocket endpoint invoked. +
This Header field is mandatory on the first WebSocket message only.
|Delimiter |A string with values : "-289907289". This value is used to mark the delimitation between the header and the payload on message that needs authentication. +
This Header field is mandatory on the first WebSocket message only.
|WebSocket Payload |A JSON string representing a dataframe. See the section <<dataframe-json>> for more details
|====================

[[about-websocket-authorization]]
==== About WebSocket Authorization

With WebSocket, the following string must be used to create the Authorization hash code.

[width="100%",cols="<25%,<75%",options="header",]
|================================================================================================================
|Item |Description
|Authorization |Signature
|Signature |Base64( HMAC-SHA2(UTF-8-Encoding-Of( StringToSign ) ) );
|StringToSign |```Content-MD5 + "\n" +
SymetryML-Secret-Key + "\n" +
Sym-Date Header + "\n" +
SymetryML-key-Id + "\n" +
RequestBody + "\n" +
ServicePath + "\n" +
extraKeys```
|Sym-Date format |See the section <<symetryml-date-header>>
|ServicePath |Path of the URL to be invoked (for instance /symetry/ws/predict).
|extraKeys |Each extra key should be included individually on a separate new line. See example below for details.
|================================================================================================================

[[example-of-websocket-string-to-sign]]
===== Example of WebSocket String to Sign
....
H47KwjgTU5G7v8BJS+ttgg== + '\n'
<SECRETKEY> + '\n'
2014-10-24 17:24:04 + '\n'
c1 + '\n'
{"attributeNames":["sepal_length","sepal_width","petal_length"],"data":[["4.3","3","1.1"]],"attributeTypes":["C","C","C"]} + '\n'
/symetry/ws/predict + '\n'
irisTest + '\n'
testLDA
....

[[learning-using-websocket]]
=== Learning Using WebSocket

This API function call allows users to learn a dataframe using WebSocket services.

[[url-43]]
==== URL
....
ws://SERVER_HOST/symetry/ws/learn
....

[[extra-parameter]]
==== Extra Parameter

[width="100%", cols="<25%,<25%,<50%",options="header",]
|===================================================================
|Index |Short Description |Description
|0 |SymetryML Project ID |The name of the project to learn the data.
|===================================================================

[[ws-response]]
==== WS Response

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|==================================================

[[sample-ws-request]]
==== Sample WS Request
....
Request URL:
ws://charm:8080/symetry/ws/learn
Request Message:
{"headers":["2014-10-24 14:28:03","PuAtwbvTrwlX8JQHWvtv7Q\u003d\u003d","Rz/EO7GXX/KE2Jj52+kePmIrudA\u003d","c1"],"extraKeys":["irisTest"]}-289907289{"attributeNames":["sepal_length","sepal_width","petal_length","petal_width","sepal_lengt_b1","sepal_lengt_b2","sepal_width_b1","sepal_width_b2","petal_length_b1","petal_length_b2","petal_width_b1","petal_width_b2","Iris_setosa","Iris_versicolor","Iris_virginica"],"data":[["4.3","3","1.1","0.1","1","0","0","1","1","0","1","0","1","0","0"],["4.8","3","1.4","0.1","1","0","0","1","1","0","1","0","1","0","0"],["4.9","3.1","1.5","0.1","1","0","0","1","1","0","1","0","1","0","0"],["4.9","3.
(...)
5","0","1","0","1","0","1","0","1","0","0","1"],["7.2","3.6","6.1","2.5","0","1","0","1","0","1","0","1","0","0","1"]],"attributeTypes":["C","C","C","C","B","B","B","B","B","B","B","B","B","B","B"]}
....

[[forgetting-using-websocket]]
=== Forgetting Using WebSocket

This API function call allows users to forget a <<dataframe-json>> of data using WebSocket services.

[[url-44]]
==== URL
....
ws://SERVER_HOST/symetry/ws/forget
....

[[extra-parameter-1]]
==== Extra Parameter

[width="100%", cols="<25%,<25%,<50%",options="header",]
|===================================================================
|Index |Short Description |Description
|0 |SymetryML Project ID |The name of the project to learn the data.
|===================================================================

[[ws-response-1]]
==== WS Response

[width="100%", cols="<25%,<25%,<50%",options="header",]
|==================================================
|HTTP Status Code |HTTP Status Message |Description
|200 |OK |Success.
|==================================================

[[predicting-using-websocket]]
=== Predicting Using WebSocket

This API function call allows users to predict using WebSocket services.

[[url-45]]
==== URL
....
ws://SERVER_HOST/symetry/ws/predict
....
[[extra-parameter-2]]
==== Extra Parameter

[width="100%", cols="<25%,<25%,<50%",options="header",]
|===================================================================
|Index |Short Description |Description
|0 |SymetryML Project ID |The name of the project to learn the data.
|1 |Model Id |The model name to use to make predictions.
|===================================================================

[[ws-response-2]]
==== WS Response

On success this WebSocket call will return a JSONResponseClient containing a <<ksvsmap-json>> entity. The format of this response is the same as with the SymetryML REST prediction API described in <<prediction-api>>.

[[sample-ws-request-1]]
==== Sample WS Request
....
Request URL
ws://charm:8080/symetry/ws/predict

Request Message:
{"headers":["2014-10-24 17:17:58","H47KwjgTU5G7v8BJS+ttgg\u003d\u003d","/Xd/JypB3rDQ+1BVaZRm6n35kt0\u003d","c1"],"extraKeys":["irisTest","testLDA"]}-289907289{"attributeNames":["sepal_length","sepal_width","petal_length"],"data":[["4.3","3","1.1"]],"attributeTypes":["C","C","C"]}

Response:
{"statusCode":"OK","statusString":"OK","values":{"KSVSMap":{"values":[{"res":"1","normZ":"0.2929126883636288","resZ":"-0.4559922893809558","z0":"-3.840891864408894","z1LTz0":"false"}]}}}
....

[[AppendixA]]
== Appendix A JSON Data Structure Schema

This appendix describes the JSON schemas used in various SymetryML REST API HTTP request and response body. This is not a pure JSON schema definition because JSON schemas do not have a primitive type for hash map, while the SymetryML API uses hash maps extensively in request/response messages. The JSON type ‘object’ is the closest data structure to a hash map, as it can be seen as an infinite set of key=string and values=objects. When part of a JSON structure should be a hash map, the object type is used in the schema definition.
When an entity contains an object - that is a hash map - additional comments are added that define the keys and values allowed. These comments are highlighted in red, so you can find them easily. The formats depicted in the following sections are important because this is how the REST server deserializes the HTTP request body and serializes the HTTP response body.


[[request-body-json]]
=== Request Body JSON

[[dataframe-json]]
==== DataFrame JSON

[source, json]
....
DataFrame : {
      "attributeTypes": {
          "type": "array" {
                "items": "string"
          }
      },
      "attributeNames": {
            "type": "array" {
                  "items": "string"

            }
      },
      "data" : {
            "type" : "array" {
                  "items" : "array" {
                        "items" : "string"
                  }
            }
      }
}
....

[[mlcontext-json]]
==== MLContext JSON

[source, json]
....
MLContext : {
      "targets" : "array" {
            "items" : "string"
      },
      "attributes" : "array" {
            "items" : "string"
      },,
      "inputAttributeNames" : "array" {
            "items" : "string"
      }
      "extraParameters" : object // key values hash map

}
....

[[dsinfo-json]]
==== DSInfo JSON

[source, json]
....
DSInfo : {
      "type" : "string",
      "name" : "string",
      "info" : "object",
      "extra" : "object"
}
....

[[dslistingrequest-json]]
==== DSListingRequest JSON

[source, json]
....
DSListingRequest : {
      "type" : "string",
      "path" : "string",
      "info" : "object"
}
....

[[explorecontext-json]]
==== ExploreContext JSON
The ExploreContext data structure is a list of <<mlcontext-json>>. It allows to request for a given exploration metrics with multiple attributes or attributes pairs.

[source, json]
....
ExploreContext : {
      "values" : "arrays" {
            "items" : "MLContext"
      }
}
....

[[request-main-response-json]]
=== Request Response JSON

This is the main JSON response that all REST SymetryML calls return. Depending on the call, the values, if present, will be different.

[source, json]
....
JSONResponseClient : {
    "statusCode ": {
        "type" : "number",
        "description" : "HTTP/HTTPS response code",
        "required" : true,
        "default" : "200"
    },
    "statusString" : {
        "type" : "String",
        "description" : "Contextual error information if needed",
        "required" : true,
        "default" : "No Error"
    },
    "values" : {
        "type" : "object" {
        "properties" : { // the different type of entities
            "KSKVMap" : {
                "type" : "KSVSMap"
            },
            "modelInfoResponse" : {
                "type" : "ModelInfo"
                },
            "status" : {
                "type" : "string"
            },
            "stringToSign" :{
                "type" : "string"
            },
            "KSVSMap" : {
                "type" : "KSVDMap"
            },
            "smlInfo" : {
                "type" : "ProjectInfo"
            },
            "smlInfoList" : {
                "type" : "ProjectInfoList"
            },
            "stringList" : {
                "type" : "StringList"
            },
            "jobinfo" : {
                "type" : "JobInfo"
            },
            "smlOptions" : {
                "type" : "SymetryProjectOptions"
            },
            "dataframe" : {
                "type" : "DataFrame"
            },
            "dsinfo" : {
                "type" : "DSInfo"
            },
            "dsdirectoryListing" : {
                "type" : "DSListingResponse"
            },
            "pcaValues" : {
                "type" : "DataFrame"
            },
            "pcaVectors" : {
                "type" : "DataFrame"
            },
            "pcaSumValues" : "number"
            },
            "federationInfo" : {
                "type" : "FederationInfo"
            }
        }
    }
}
....

[[response-entities]]
==== Response Entities

Response entities are JSON data structures that are returned given a specific REST request. This secondary response is added to the main response values field.

[[dslistingresponse-json]]
===== DSListingResponse JSON

[source, json]
....
DSListingResponse : {
    "ok" : "Boolean",
    "files" : {
        "type" : "array" {
            "items" : "string"
        }
    },
    "dirs" : {
        "type" : "array" {
            "items" : "string"
        }
    },
    "path" : "string",
    "marker" : "string",
    "delimiter" : "string"
}
....

[[jobinfo-json]]
===== JobInfo

[source, json]
....
JobInfo : {
    "jobId" : "number",
    "jobType" : "string",
    "owner" : "string",
    "startingDate" : "number",
    "current" : "number",
    "maximum" : "number",
    "isOnBoundedExecutor" : "Boolean",
    "isStarted" : "Boolean",
    "isDone" : "Boolean",
    "details" : "object" // <string, string> map
}
....

[[ksvdmap-json]]
===== KSVDMap

[source, json]
....
KSVDMap : {
    "values" : {
    "type" : "array" {
        "items" : "object" {
            // key : string
            // value : number
        }
    }
}
....

[[symetryprojectoptions-json]]
===== SymetryProjectOptions

[source, json]
....
SymetryProjectOptions : {
    "gpuEnabled" : "number"
}
....

[[ksvsmap-json]]
===== KSVSMap

Prediction services use KSVSMap, which consists of a list of map<string, string>.

[source, json]
....
KSVSMap : {
    "values" : {
        "type" : "array" {
            "items" : "object" {
                // key : string
                // value : string
        }
    }
}
....

[[modelinfo-json]]
===== ModelInfo

[source, json]
....
ModelInfo : {
    "modelId" : "string",
    "modelType" : "string",
    "modelBuilt" : "number",
    "buildTime" : "number",
    "attributeNames" : {
        "type" : "array" {
            "items" : "string"
        }
    },
    "attributeIndexes" : {
        "type" : "array" {
            "items" : "number"
        }
    },
    "predictInfo" : { // value returned by the predictions.
        "type" : "array" {
            "items" : "string"
        }
    },
    "scoreInfo" : { // value containing score in predictions.
        "type" : "array" {
            "items" : "string"
        }
    },
    "targetNames" : {
        "type" : "array" {
            "items" : "string"
        }
    },
    "targetindexes" : {
        "type" : "array" {
            "items" : "number"
        }
    },
    "info" : { // additional information, model type dependent.
        "type" : "KSVSMap"
    },
    "creationDate" : "number"
}
....

[[projectinfo-json]]
===== ProjectInfo


The SymetryML project info request uses ProjectInfo.

[source, json]
....
ProjectInfo : {
    "pid" : "string",
    "encoderName" : "string",
    "modelsList" : {
    "type" : "array" {
        "items" : "string"
    },
    "modelTypeList" : {
        "type" : "array" {
            "items" : "string"
        }
    },
    "dsList" : {
        "type" : "array" {
            "items" : "string"
        }
    },
    "attributeNames" : {
        "type" : "array" {
            "items" : "string"
        }
    },
    "attributeIndexes" : {
        "type" : "array" {
         "items" : "number"
        }
    },
    "attributeTypes" : { // [c,b,x,s,l,-]
        "type" : "array" {
            "items" : "string"
        }
    },
    "modelAssessments" : { 
        "type" : "array" {
            "items" : "string" 
        }
    },
    "modelPredictions" : { 
        "type" : "array" {
            "items" : "string"
        }
    },
    "partitionColumn" : "string", 
    "params" : "object", // key values hash map <string, string>
    "hash" : "number", // internal use
    "categorySeparator" : "string",
    "type" : "string", // 
    "creationDate" : "number",
    "lastModificationDate" : "number",
    "loaded" : "true|false",
    "persisted" : "true|false",
    "histogramEnabled" : "true|false"
}
....

[[stringlist-json]]
===== StringList

StringList can be returned by various REST calls.

[source, json]
....
StringList : {
    "type" : "array" {
        "items" : "string"
    }
}
....

[[projectinfolist-json]]
===== ProjectInfoList

ProjectInfoList is returned after restoring a specific SymetryML project or restoring all SymetryML projects for a specific customer.

[source, json]
....
ProjectInfoList : {
    "values" : {
        "type" : "array" {
            "items" : "ProjectInfo"
        }
    }
}
....

[[federationinfo-json]]
===== FederationInfo

The SymetryML Federation info request uses FederationInfo.

[source, json]
....
FederationInfo : {
    "aws_id" : "string",
    "aws_access_key" : "string",
    "aws_queue_url" : "string",
    "aws_secret_key" : "string",
    "aws_topic_arn" : "string",
    "fed_local_id" : "string",
    "fed_name" : "string",
    "fed_secret_key" : "string",
    "sync_sched" : "string",
    "fed_type" : "string",
    "local_uuid" : "string",
    "s3_bucket" : "string",
    "is_pulsing" : "boolean",
    "peersInfo" : "object" // key values hash map<string, string>
}
....

[[awsinfo-json]]
===== AwsInfo

Amazon Web Service - AWS - information. This information will be returned as an encrypted JSON string.

[source, java]
....
public class AwsInfo {

    /**
     * map<AWS_REGION, List<Map<topic_arn, List<Map<topic_arn_key, topic_arn_value>>>>>
     */
    public Map<String, List<Map<String, List<Map<String, String>>>>> topics;
    /**
     * Map<AWS_REGION, List<sqs_queue_name>>
     */
    public Map<String, List<String>> queues;

    // Example:
    /*
    {
      "topics":{"US_WEST_2":
        [{"arn:aws:sns:us-west-2:123456789012:fed1":
          [{"owner":"123456789012",
          "protocol":"sqs",
          "endpoint":"arn:aws:sqs:us-west-2:123456789012:fed1_proj1",
          "subscription_arn":"arn:aws:sns:us-west-2:123456789012:fed1:abcdefg1-8616-4c57-873f-abcdfef12345"}
          ]}
        ],
        "US_EAST_1":
        [{"arn:aws:sns:us-east-1:123456789012:FEEED":
          [{"owner":"123456789012",
          "protocol":"sqs",
          "endpoint":"arn:aws:sqs:us-east-1:123456789012:FEEED_toto",
          "subscription_arn":"arn:aws:sns:us-east-1:123456789012:FEEED:abcdefg1-8eaf-4c22-8062-abcdfef12345"}]
        },
        {"arn:aws:sns:us-east-1:123456789012:f200":
          [{"owner":"123456789012",
          "protocol":"sqs",
          "endpoint":"arn:aws:sqs:us-east-1:123456789012:f200_p1",
          "subscription_arn":"arn:aws:sns:us-east-1:123456789012:f200:abcdefg1-a665-4e82-961b-abcdfef12345"}]
        }
      },
      "queues":{
        "US_WEST_2":[
          "https://sqs.us-west-2.amazonaws.com/123456789012/fed1_proj1"],
        "US_EAST_1":[
        "https://sqs.us-east-1.amazonaws.com/123456789012/FEEED_toto",
        "https://sqs.us-east-1.amazonaws.com/123456789012/f200_p1",
        ]
      }
    }
    */
}
....

[[density-json]]
===== Density

DensityList contains a list of Density

[source, json]
....
Density : {
    "attrName" : "string",
    "min" : "number",
    "max" : "number",
    "width" : "number",
    "histogram" : "array" {
            "items" : "number"
        },
    "error" : "string"
}
....
[[densitylist-json]]
===== Density List

DensityList contains a list of <<density-json>>

[source, json]
....
DensityList : {
    "values" : {
        "type" : "array" {
            "items" : "Density"
        }
    }
}
....



[[appendixb]]
== Appendix B Samples Code

[[authentication-code-signature-example]]
=== Authentication Code Signature Example

Taken from https://mattyboy.net/code/hmac-sha1-java-python-and-php/

This section provides an example of how to sign a REST query in Java and Python. Code examples are included.

*Java example:*
[source, java]
....
import org.apache.commons.codec.binary.Base64;
import org.apache.commons.codec.binary.Hex;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
public class Signer {
    public static void main(String[] args) throws Exception
    {
	    // REPLACE ‘key’ WITH YOUR SYMETRYML SECRET KEY.
        String key = "0f2100e34b54d50fd0138f300d3497579dae5279";
        String data = "secret-message";
        byte[] decodedKey = Hex.decodeHex(key.toCharArray());
        SecretKeySpec keySpec = new SecretKeySpec(decodedKey, "HmacSHA2");
        Mac mac = Mac.getInstance("HmacSHA1");
        mac.init(keySpec);
        byte[] dataBytes = data.getBytes("UTF-8");
        byte[] signatureBytes = mac.doFinal(dataBytes);
        String signature = new String(Base64.encodeBase64(signatureBytes), "UTF-8");
        System.out.println("key = " + key);
        System.out.println("data = " + data);
        System.out.println("signature = " + signature);
    }
}
....

*Python 2.7 example:*
[source,python]
....
import hashlib
import hmac
import base64

key = "0f2100e34b54d50fd0138f300d3497579dae5279"
data = "secret-message"

hmac = hmac.new(
    key.encode("utf-8"), 
    data.encode('utf-8'), 
    hashlib.sha256)
signature = base64.b64encode(hmac.digest())

print "key =", key
print "data =", data
print "signature =", signature
....

*Expected result:*
....
key = 0f2100e34b54d50fd0138f300d3497579dae5279
data = secret-message
signature = op/4IM8dc5DwpUYBhywVl0V5ddlEMjFRq6qfKOj2+io=
....

*Python 3.x example:*
[source,python]
....
import hashlib
import hmac
import base64

key = '0f2100e34b54d50fd0138f300d3497579dae5279'
data = "secret-message"

hmac = hmac.new(
    bytes(key, 'utf-8'), 
    bytes(data, 'utf-8'), 
    hashlib.sha256)
signature = base64.b64encode(hmac.digest())
print ("key =", key)
print ("data =", data)
print ("signature =", signature)
....

*Expected result:*
....
key = 0f2100e34b54d50fd0138f300d3497579dae5279
data = secret-message
signature = op/4IM8dc5DwpUYBhywVl0V5ddlEMjFRq6qfKOj2+io=
....

*Signing a REST request without request body:*
[source,java]
....
import org.eclipse.jetty.client.HttpClient;
String url = "http://symetryml.com:8080/symetryml/c1/projects";
String verb "GET";
String md5 = null; // md5 is for request body
String secretKey = "VLmAm+WkpnA5zp2wXiSYkw==";
String date = null; //
String customerId = "c1";
String body = null;
String path = "symetry/rest/c1/projects";
String query = null;

MsgAuthentication ma = new MsgAuthentication();
Msg.setSecretKey(secretKey);

String signature = ma.getMACForMessage(
verb,
md5,
secretKey,
date,
customerId,
body,
path,
query);
date = ma.getLastDate();
HttpClient client = new HttpClient();
Client.start();
Request r = client.newRequest(url);
r = r.method(HttpMethod.GET);
r = r.header("Authorization", signature);
r = r.header("sym-date", date);
r = r.header("content-md5", md5);
r = r.header("sym-version", "5.0");

r.send();

....

*Signing a REST request with a request body:*
[source,java]
....
import org.eclipse.jetty.client.HttpClient;
String url = "http://symetryml.com:8080/symetry/rest/c1/projects/projectOne/learn";
String body = "some request body";
MsgAuthentication ma = new MsgAuthentication();
String verb = "POST";
String md5 = ma.getMD5(body);
String secretKey = "VLmAm+WkpnA5zp2wXiSYkw==";
String date = null; //
String customerId = "c1";
String path = "symetry/rest/c1/projects";
String query = null;
msg.setSecretKey(secretKey);
String signature = ma.getMACForMessage(
verb,
md5,
secretKey,
date,
customerId,
body,
path,
query);
date = ma.getLastDate();
HttpClient client = new HttpClient();
Client.start();
Request r = client.newRequest(url);
r = r.method(HttpMethod.POST);
r = r.header("Authorization", signature);
r = r.header("sym-date", date);
r = r.header("content-md5", md5);
r = r.header("sym-version", SYM_VERSION);

r.send();

....

*Java Script Signature code:*
[source,javascript]
....
SignUtil.getSignature = function(
    inVerb,
    inContentMD5,
    inSecretKey,
    inDateString,
    inKey,
    inJsonBody,
    inPath,
    inQuery)
{
    var secretKeyDecoded = CryptoJS.enc.Base64.parse(inSecretKey);
    var toSign = inVerb   + "\n" +
        inContentMD5  + "\n" +
                inSecretKey   +  "\n" +
                inDateString  +  "\n" +
                inKey         +  "\n";
        if(inJsonBody){
            toSign = toSign + inJsonBody + "\n";
        }
        toSign = toSign + inPath + "\n";
        if(inQuery) {
        toSign = toSign + inQuery + "\n";
        }
    var signature = CryptoJS.HmacSHA256(toSign, secretKeyDecoded);
    var base64sign = CryptoJS.enc.Base64.stringify(signature);
    return base64sign;
};

....

[[aes-encryption-example]]
=== AES Encryption Example

This section provides examples on how to encrypt text, so the REST server can decrypt it correctly using the user secret 128-bit AES key. Examples are provided in Java, JavaScript, and Python.

==== Python example:

TBD

==== JavaScript example:
[source, javascript]
....
encryptText = function(inText)
{
	var secretKey = GlobalUtil.getSecretKey();
	var ivB64 = 'LzM5QUtXZXWHm7HJ4wAePg==';
	var secretKeyDecoded = CryptoJS.enc.Base64.parse(secretKey);
	var iv  = CryptoJS.enc.Base64.parse(ivB64);
	var encrypted = CryptoJS.AES.encrypt(inText, secretKeyDecoded,
		{mode: CryptoJS.mode.CBC,iv : iv});
	var rval = encrypted.ciphertext.toString(CryptoJS.enc.Base64);
	return rval;
};

....

==== Java exemple:
[source, java]
....
import org.apache.commons.codec.binary.Base64;
public class TestEncryption {
	public static void main(String[] args)
	{
		try {
			test();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	public static String generateKey() throws NoSuchAlgorithmException
	{
        	KeyGenerator kgen = KeyGenerator.getInstance("AES");
       	 	kgen.init(128);
        	SecretKey skey = kgen.generateKey();
        	byte[] raw = skey.getEncoded();
        	String key = new Base64().encodeAsString(raw);
        	System.out.println("the key<\n" + key + "\n>" + skey.toString());
        	return key;
	}
	private static void test() throws Exception
	{
		String data = "Message to encrypt";
		String key = "EYpWjGPaoMoFUb/jfW95PQ=="; // generateKey();
		String e = encrypt(key, data);
		System.out.println("encrypted <" + e +">");
		String d = decrypt(key, e);
		System.out.println("decrypted <" + d +">");
	}
	private static String encrypt(
	        String key,
	        String data) throws Exception
	{
		IvParameterSpec iv = getIV();
		Base64 b64 = new Base64();
		byte []bbk = b64.decode(key.getBytes("UTF-8"));
		SecretKeySpec skeySpec = new SecretKeySpec(bbk, "AES");
        	Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        	cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);
        	String encrypted = (new Base64()).encodeAsString(
        	cipher.doFinal(data.getBytes("UTF-8")));
        	return encrypted;
	}
	private static IvParameterSpec getIV() throws Exception
	{
		Base64 b64 = new Base64();
		String ivS = "LzM5QUtXZXWHm7HJ4wAePg==";
		byte []bb = b64.decode(ivS.getBytes("UTF8"));
		IvParameterSpec iv = new IvParameterSpec(bb);
		return iv;
	}
	private static String decrypt(
	        String key,
	        String encrypted) throws Exception
	{
		IvParameterSpec iv = getIV();
		Base64 b64 = new Base64();
		byte []keyb = b64.decode(key.getBytes("UTF-8"))
		// decrypt
        	Key k = new SecretKeySpec(keyb, "AES");
        	Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding");
        	c.init(Cipher.DECRYPT_MODE, k, iv);
        	byte[] decodedValue = new Base64().decode(encrypted);
        	byte[] decValue = c.doFinal(decodedValue);
        	String decryptedValue = new String(decValue);
        	return decryptedValue;
	}
}
....
